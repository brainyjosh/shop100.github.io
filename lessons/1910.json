{"lesson":{"id":1910,"name":"Polymorphism","type":0,"mode":1,"videoID":"R_PPA9eejDw","tags":"polymorphism","quizzes":[{"id":3769,"number":1,"videoStart":9.0,"videoEnd":108.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":78392,"text":"...one function, with different implementations","isCorrect":true,"properties":{}},{"id":78393,"text":"...one implementation, with different functions","isCorrect":false,"properties":{}},{"id":78394,"text":"...each implementation in a different function","isCorrect":false,"properties":{}}],"question":"Briefly, polymorphism is...","textContent":"[h1]Polymorphism[/h1]\r\n\r\nThe word [b]polymorphism [/b]means \"having many forms\".\r\nTypically, polymorphism occurs when there is a hierarchy of classes and they are related by [b]inheritance[/b].\r\n\r\nC++ polymorphism means that a call to a member function will cause a [b]different [/b]implementation to be executed depending on the [b]type [/b]of object that invokes the function.\r\n[note]Simply, polymorphism means that a single function can have a number of different implementations.[/note]"},{"id":3770,"number":2,"videoStart":109.0,"videoEnd":176.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":95189,"text":"class","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":95190,"text":"protected","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":95191,"text":"public","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":95192,"text":"int","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to declare a class ''Enemy'', with a protected variable ''attackPower'' and a public function ''setAttackPower''.\r\n[!raw!]\r\n{0} Enemy {\r\n{1}:\r\n int attackPower;\r\n{2}:\r\n void setAttackPower({3} a) {\r\n  attackPower = a;\r\n }\r\n};","textContent":"[h1]Polymorphism[/h1]\r\n\r\n[b]Polymorphism [/b]can be demonstrated more clearly using an example:\r\nSuppose you want to make a simple game, which includes different enemies: monsters, ninjas, etc. All enemies have one function in common: an [b]attack [/b]function. However, they each attack in a different way. In this situation, polymorphism allows for calling the same [b]attack [/b]function on different objects, but resulting in different behaviors. \r\n\r\nThe first step is to create the [b]Enemy [/b]class.[code format=\"cpp\"]class Enemy {\r\n protected: \r\n  int attackPower;\r\n public:\r\n  void setAttackPower(int a){\r\n   attackPower = a;\r\n  }\r\n};[/code]\r\n[note]Our Enemy class has a public method called [b]setAttackPower[/b], which sets the protected [b]attackPower [/b]member variable.[/note]"},{"id":3771,"number":3,"videoStart":181.0,"videoEnd":406.0,"linkedVideoID":null,"type":6,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":95193,"text":"Ninja","isCorrect":true,"properties":{}},{"id":95194,"text":"Monster","isCorrect":true,"properties":{}},{"id":95195,"text":"&ninjaObj","isCorrect":true,"properties":{}},{"id":95196,"text":"Enemy*","isCorrect":true,"properties":{}},{"id":95197,"text":"pointer","isCorrect":false,"properties":{}},{"id":95198,"text":"class","isCorrect":false,"properties":{}}],"question":"Fill in the blanks to declare ''Ninja'' and ''Monster'' objects, and then two ''Enemy'' pointers that point to the ''Ninja'' object and the ''Monster'' object, respectively.\r\n[!raw!]\r\n{0} ninjaObj;\r\n{1} monsterObj;\r\nEnemy* e1 = {2};\r\n{3} e2 = &monsterObj;","textContent":"[h1]Polymorphism[/h1]\r\n\r\nOur second step is to create classes for two different types of enemies, [b]Ninjas [/b]and [b]Monsters[/b]. Both of these new classes inherit from the [b]Enemy [/b]class, so each has an attack power. At the same time, each has a specific [b]attack [/b]function. [code format=\"cpp\"]class [b]Ninja[/b]: public Enemy {\r\n public:\r\n  void attack() {\r\n   cout << \"Ninja! - \"<<attackPower<<endl;\r\n  }[b]\r\n[/b]};\r\n\r\nclass [b]Monster[/b]: public Enemy {\r\n public:\r\n  void attack() {\r\n   cout << \"Monster! - \"<<attackPower<<endl;\r\n  }\r\n};[/code]\r\nAs you can see, their individual [b]attack [/b]functions differ.\r\nNow we can create our [b]Ninja [/b]and [b]Monster [/b]objects in main. [code format=\"cpp\"]int main() {   \r\n [b]Ninja [/b]n;\r\n [b]Monster [/b]m;  \r\n}[/code]\r\n[b]Ninja [/b]and [b]Monster [/b]inherit from [b]Enemy[/b], so all [b]Ninja [/b]and [b]Monster [/b]objects are [b]Enemy [/b]objects. This allows us to do the following:[code format=\"cpp\"][b]Enemy [/b]*e1 = &n;\r\n[b]Enemy [/b]*e2 = &m;[/code]\r\n[note]We've now created two pointers of type [b]Enemy[/b], pointing them to the [b]Ninja [/b]and [b]Monster [/b]objects.[/note]"},{"id":3772,"number":4,"videoStart":407.0,"videoEnd":592.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":97861,"text":"*","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":97862,"text":"&","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":97863,"text":"->","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":97864,"text":"->","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":97865,"text":"attack","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to declare Enemy pointers to the ''Ninja'' and ''Monster'' objects. Set the ''attackPower'' of those objects via ''Enemy'' pointers, then call attack() functions of both ''Ninja'' and ''Monster'' objects:\r\n[!raw!]\r\nEnemy{0} e1 = &ninjaObj;\r\nEnemy* e2 = {1}monsterObj;\r\ne1{2}setAttackPower(29);\r\ne2{3}setAttackPower(99);\r\nninjaObj.attack();\r\nmonsterObj.{4}();","textContent":"[h1]Polymorphism[/h1]\r\n\r\nNow, we can call the corresponding functions: [code format=\"cpp\" codeId=\"270\"]int main() {\r\n  Ninja n;\r\n  Monster m;\r\n  Enemy *e1 = &n;\r\n  Enemy *e2 = &m;\r\n\r\n[b] e1->setAttackPower(20);\r\n e2->setAttackPower(80);\r\n\r\n n.attack();\r\n m.attack();[/b]\r\n}\r\n\r\n/* Output:\r\nNinja! - 20\r\nMonster! - 80\r\n*/[/code]\r\nWe would have achieved the same result by calling the functions directly on the objects. However, it's faster and more efficient to use pointers. \r\nAlso, the pointer demonstrates, that you can use the [b]Enemy [/b]pointer without actually knowing that it contains an object of the subclass.\r\n[note]In this example, polymorphism is using a member function ([b]setAttackPower[/b]) of the base class ([b]Enemy[/b]) to access private members in the derived classes.\r\nTap [b]Continue [/b]to learn more![/note]"}]}}