{"lesson":{"id":2471,"name":"Data Hiding","type":0,"mode":1,"videoID":null,"tags":"data-hiding","quizzes":[{"id":5139,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":87982,"text":"A method that can't be accessed from outside a class","isCorrect":false,"properties":{}},{"id":87983,"text":"A method with double underscores at the beginning and end","isCorrect":false,"properties":{}},{"id":87984,"text":"A method external code is discouraged from using","isCorrect":true,"properties":{}}],"question":"What is a private method in Python?","textContent":"[h1]Data Hiding[/h1]\r\n\r\nA key part of object-oriented programming is [b]encapsulation[/b], which involves packaging of related variables and functions into a single easy-to-use object - an instance of a class.\r\nA related concept is [b]data hiding[/b], which states that implementation details of a class should be hidden, and a clean standard interface be presented for those who want to use the class. \r\nIn other programming languages, this is usually done with private methods and attributes, which block external access to certain methods and attributes in a class.\r\n\r\nThe Python philosophy is slightly different. It is often stated as [b]\"we are all consenting adults here\"[/b], meaning that you shouldn't put arbitrary restrictions on accessing parts of a class. Hence there are no ways of enforcing a method or attribute be strictly private. \r\n[note]However, there are ways to discourage people from accessing parts of a class, such as by denoting that it is an implementation detail, and should be used at their own risk.[/note]"},{"id":5140,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":98279,"text":"To prevent it being called by external code","isCorrect":false,"properties":{}},{"id":98280,"text":"To mark it as private","isCorrect":true,"properties":{}},{"id":98281,"text":"To make it faster","isCorrect":false,"properties":{}}],"question":"What is the purpose of prefacing a method name with a single underscore?","textContent":"[h1]Data Hiding[/h1]\r\n\r\nWeakly private methods and attributes have a [b]single underscore [/b]at the beginning.\r\nThis signals that they are private, and shouldn't be used by external code. However, it is mostly only a convention, and does not stop external code from accessing them. \r\nIts only actual effect is that [b]from module_name import *[/b] won't import variables that start with a single underscore.\r\n[b]Example:[/b] [code format=\"py\" codeId=\"416\"]class Queue:\r\n  def __init__(self, contents):\r\n    self.[b]_hiddenlist [/b]= list(contents)\r\n\r\n  def push(self, value):\r\n    self.[b]_hiddenlist[/b].insert(0, value)\r\n   \r\n  def pop(self):\r\n    return self.[b]_hiddenlist[/b].pop(-1)\r\n\r\n  def __repr__(self):\r\n    return \"Queue({})\".format(self.[b]_hiddenlist[/b])\r\n\r\nqueue = Queue([1, 2, 3])\r\nprint(queue)\r\nqueue.push(0)\r\nprint(queue)\r\nqueue.pop()\r\nprint(queue)\r\nprint(queue._hiddenlist)[/code]\r\n[b]Result:[/b] [code format=\"raw\" ]>>>\r\nQueue([1, 2, 3])\r\nQueue([0, 1, 2, 3])\r\nQueue([0, 1, 2])\r\n[0, 1, 2]\r\n>>> [/code]\r\n[note]In the code above, the attribute [b]_hiddenlist [/b]is marked as private, but it can still be accessed in the outside code.\r\nThe [b]__repr__[/b] magic method is used for string representation of the instance.[/note]"},{"id":5141,"number":3,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":2,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":98282,"text":"_b__a","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"How would the attribute __a of the class b be accessed from outside the class?","textContent":"[h1]Data Hiding[/h1]\r\n\r\nStrongly private methods and attributes have a[b] double underscore[/b] at the beginning of their names. This causes their names to be mangled, which means that they can't be accessed from outside the class. \r\nThe purpose of this isn't to ensure that they are kept private, but to avoid bugs if there are subclasses that have methods or attributes with the same names.\r\nName mangled methods can still be accessed externally, but by a different name. The method [b]__privatemethod[/b] of class [b]Spam [/b]could be accessed externally with[b] _Spam__privatemethod[/b].\r\n[b]Example:[/b] [code format=\"py\" codeId=\"417\"]class Spam:\r\n [b] __egg = 7[/b]\r\n  def print_egg(self):\r\n    print(self.__egg)\r\n\r\ns = Spam()\r\ns.print_egg()\r\nprint(s._Spam__egg)\r\nprint(s.__egg)[/code]\r\n[b]Result:[/b] [code format=\"raw\" ]>>>\r\n7\r\n7\r\nAttributeError: 'Spam' object has no attribute '__egg'\r\n>>>[/code]\r\n[note]Basically, Python protects those members by internally changing the name to include the class name.[/note]"}]}}