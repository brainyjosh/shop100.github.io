{"lesson":{"id":2685,"name":"Interfaces","type":0,"mode":1,"videoID":null,"tags":"interfaces","quizzes":[{"id":5571,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":104065,"text":"Yes","isCorrect":false,"properties":{}},{"id":104066,"text":"No","isCorrect":true,"properties":{}}],"question":"Is the following interface valid?\r\npublic interface ITest {\r\n  int test;\r\n  void Func();\r\n}","textContent":"[h1]Interfaces[/h1]\r\n\r\nAn [b]interface[/b] is a completely abstract class, which contains [b]only[/b] abstract members.\r\nIt is declared using the [b]interface [/b]keyword: [code format=\"cs\" ]public [b]interface [/b]IShape\r\n{\r\n  void Draw();\r\n}[/code]\r\nAll members of the interface are by default abstract, so no need to use the abstract keyword. \r\nAlso, all members of an interface are always public, and no access modifiers can be applied to them.\r\n[note]It is common to use the capital letter [b]I[/b] as the starting letter for an interface name.\r\nInterfaces can contain properties, methods, etc. but [b]cannot[/b] contain fields (variables).[/note]"},{"id":5572,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":104087,"text":"interface","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":104088,"text":"class","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":104089,"text":":","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":104090,"text":"void","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to create an interface and implement it.\r\n[!raw!]\r\n{0} IAnimal {\r\n  void Eat();\r\n}\r\n{1} Dog{2} IAnimal {\r\n  public {3} Eat() {\r\n    Console.WriteLine(\"Omnomnom\");\r\n  }\r\n}","textContent":"[h1]Interfaces[/h1]\r\n\r\nWhen a class [b]implements[/b] an interface, it must also implement, or define, all of its methods.\r\nThe term[b] implementing an interface[/b] is used (opposed to the term \"inheriting from\") to describe the process of creating a class based on an interface. The interface simply describes what a class should do. The class implementing the interface must define how to accomplish the behaviors.\r\nThe syntax to implement an interface is the same as that to derive a class: [code format=\"cs\" codeId=\"903\"]public interface IShape {\r\n  void Draw();\r\n}\r\nclass Circle : IShape {\r\n  public void Draw() {\r\n    Console.WriteLine(\"Circle Draw\");\r\n  }\r\n}\r\nstatic void Main(string[] args) {\r\n  IShape c = new Circle();\r\n  c.Draw();\r\n  //Outputs \"Circle Draw\"\r\n}[/code]\r\nNote, that the [b]override[/b] keyword is not needed when you implement an interface.\r\n[note]But why use interfaces rather than abstract classes? \r\nA class can inherit from just one base class, but it can implement [b]multiple[/b] interfaces!\r\nTherefore, by using interfaces you can include behavior from multiple sources in a class.\r\nTo implement multiple interfaces, use a comma separated list of interfaces when creating the class: [b]class A: IShape, IAnimal, etc.[/b][/note]"}]}}