{"lesson":{"id":2732,"name":"Access Modifiers","type":0,"mode":1,"videoID":null,"tags":"access-modifiers","quizzes":[{"id":5742,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":113383,"text":"public","isCorrect":true,"properties":{}},{"id":113384,"text":"private","isCorrect":false,"properties":{}}],"question":"By default, all methods in a class are:","textContent":"[h1]Access Modifiers[/h1]\r\n\r\nUntil now, all the methods that we defined in our classes were publicly available, meaning that you could call those methods from outside of the class.\r\nThere are certain situations when methods should only be visible to the class. For example, imagine a Banking class with methods to calculate values for internal transactions and operations. If these methods were available outside the class, the reliability of the data could be at risk.\r\nTo control visibility, Ruby provides the  [b]public[/b], [b]private[/b], and [b]protected [/b]access modifiers.\r\nBy default, all class methods (except initialize) are [b]public[/b], meaning that they are accessible from both inside and outside of the class. \r\nTo make a method accessible only from inside the class, we can use the [b]private [/b]access modifier: [code format=\"rb\" codeId=\"1075\"]class Person\r\n  def initialize(age)\r\n    @age = age\r\n  end\r\n  def show\r\n    puts \"#{@age} years = #{days_lived} days\"\r\n  end\r\n\r\n  [b]private[/b]\r\n  def days_lived\r\n    @age * 365\r\n  end\r\nend\r\n\r\np = Person.new(42)\r\np.show[/code]\r\nIn the code above, the method [b]days_lived [/b]is private and is only accessible inside the class. We called it from the [b]show [/b]method, which is [b]public[/b].\r\nIf we try to call the [b]days_lived [/b]method from an object ([b]puts p.days_lived[/b]), we will get an error.\r\n[note]When the reserved word [b]private [/b]is used in a program, anything below it in the class is private (unless [b]public [/b]or [b]protected [/b]is placed after it to negate it).\r\nAccess modifiers can be applied only to methods. Instance variable are always [b]private[/b].[/note]"},{"id":5743,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":113394,"text":"public","isCorrect":false,"properties":{}},{"id":113395,"text":"private","isCorrect":false,"properties":{}},{"id":113396,"text":"protected","isCorrect":true,"properties":{}}],"question":"In order to make the methods private and be able to call them using a receiver, you need to make them:","textContent":"[h1]Protected[/h1]\r\n\r\nAn interesting thing to note about private Ruby methods is that they cannot be called with an explicit receiver, even if that receiver is itself. When we say \"receiver\",  we mean the object that the method is being called from. Even if we try to call the private method with [b]self[/b] we will get an error.\r\nThis can be needed when, for example, overloading an operator to compare two objects using a private method. \r\nTo demonstrate that, let's define a class [b]Product [/b]with a [b]private [/b]method [b]id[/b]. If the ids of two products are equal, then they are considered equal: [code format=\"rb\" codeId=\"1078\"]class Product\r\n  attr_accessor :name, :num\r\n  def initialize(name, num)\r\n    @name = name\r\n    @num = num\r\n  end\r\n  def ==(other)\r\n    self.id == other.id\r\n  end\r\n  [b]private[/b]\r\n  def id\r\n    name.length*num\r\n  end\r\nend\r\n\r\np1 = Product.new(\"PC\", 5)\r\np2 = Product.new(\"Laptop\", 3)\r\nputs (p1 == p2)\r\n# outputs \"...Error: private method 'id' called...\"[/code]\r\nThis code generates an error, because we tried to call the [b]private [/b]method [b]id [/b]on [b]self [/b]and the [b]other [/b]object.\r\nTo be able to do that without making the method public, Ruby has the [b]protected [/b]access control.\r\nIf we change the method from private to protected, the code will work: [code format=\"rb\" codeId=\"1077\"]class Product\r\n  attr_accessor :name, :num\r\n  def initialize(name, num)\r\n    @name = name\r\n    @num = num\r\n  end\r\n  def ==(other)\r\n    self.id == other.id\r\n  end\r\n  [b]protected[/b]\r\n  def id\r\n    name.length*num\r\n  end\r\nend\r\n\r\np1 = Product.new(\"PC\", 5)\r\np2 = Product.new(\"Laptop\", 3)\r\nputs (p1 == p2) \r\n# outputs false[/code]\r\n[note]So, [b]protected [/b]methods are not accessible from outside code, just like private methods, but can be called for an object of the same class or subclasses.[/note]"}]}}