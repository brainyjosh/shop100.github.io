{"lesson":{"id":2351,"name":"Closures","type":0,"mode":1,"videoID":null,"tags":"closures","quizzes":[{"id":4802,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":65741,"text":"Nested functions","isCorrect":true,"properties":{}},{"id":65742,"text":"Global functions","isCorrect":true,"properties":{}},{"id":65743,"text":"Variables","isCorrect":false,"properties":{}},{"id":65744,"text":"Arrays","isCorrect":false,"properties":{}}],"question":"Which of the following are examples of closures?","textContent":"[h1]Closures[/h1]\r\n\r\n[b][/b]A [b]Closure [/b]is a self-contained block of functionality that can be passed around and used in your code.\r\n\r\nGlobal and nested functions are actually special kinds of closures.\r\n\r\nNested functions offer a convenient way to name and define self-contained blocks of code within a larger function. \r\n[note]However, it is sometimes useful to have the option of writing shorter versions of function-like constructs that do not require full declarations and names. This is particularly true when working with functions that take other functions as one or more of their arguments.[/note]"},{"id":4927,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":96676,"text":"Yes","isCorrect":false,"properties":{}},{"id":96677,"text":"No","isCorrect":true,"properties":{}}],"question":"Can you use default values for the parameters in closure expressions?","textContent":"[h1]Closures[/h1]\r\n[b]\r\nClosure expressions[/b] present a way to write inline closures using brief, focused syntax. Closure expressions offer a number of syntax optimizations for use in writing closures in a shortened form, without losing clarity or intent.\r\n\r\nClosure expression syntax takes the following general form: [code format=\"swift\"]{ ([b]parameters[/b]) -> [b]return type[/b] in\r\n            [b]statements[/b]\r\n}[/code]\r\n[note]Closure expression syntax can use constant parameters, variable parameters, and inout parameters, but default values cannot be used. Variadic parameters can be used if you name them and make sure that it's placed last in the parameter list.[/note]"},{"id":4803,"number":3,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":96678,"text":"{","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":96679,"text":"in","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":96680,"text":"}","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to create an inline closure.\r\n[!raw!]\r\nasc = names.sort(\r\n  {0} (s1: String, s2: String) -> Bool {1}\r\n   return s1 < s2\r\n{2} )","textContent":"[h1]The Sort Function[/h1]\r\n\r\nTo understand how Closures are used, let's take a look at a function called [b]sort[/b], which is available in Swift's standard library. The sort function orders an array of values of a known type.\r\n\r\nThe [b]sort [/b]method takes two arguments:\r\n- An array of values of a known type.\r\n- A closure that takes two arguments of the same type as the array's contents, and returns a Bool value to say whether the first value should appear [i]before [/i]or [i]after [/i]the second value once the sorting is complete.\r\n\r\nThe example below shows the sorting of an array of String values. The sorting closure needs to be a function of type [b](String, String) -> Bool[/b].\r\nOne way to provide the sorting closure is to write a normal function of the correct type, and to pass it in as the [b]sort [/b]method's parameter: [code format=\"swift\"]func backwards(s1: String, s2: String) -> Bool {\r\n   return s1 > s2\r\n}\r\nlet names = [\"Cc\", \"Aa\", \"Ee\", \"Bb\", \"Dd\"]\r\nvar reversed = names.[b]sort(backwards)[/b][/code]\r\nThe example compares the Strings in the array names, based on the [b]backwards [/b]function.\r\nHowever, this is a long-winded way to write what is really a function that contains a single-expression (a > b). \r\nIn this situation, it would be preferable to write the sorting closure [b]inline[/b], using closure expression syntax: [code format=\"swift\"]let names = [\"Cc\", \"Aa\", \"Ee\", \"Bb\", \"Dd\"]\r\nreversed = names.sort([b]{ (s1: String, s2: String) -> Bool in\r\n   return s1 > s2\r\n}[/b])[/code]\r\nFor the inline closure expression, the parameters and return type are written within the curly braces, rather than outside of them.\r\n[note]The [b]in [/b]keyword is used to introduce the beginning of the closure's body, and indicates that the definition of the closure's parameters and return type has finished, and the body of the closure is about to begin.[/note]"},{"id":4804,"number":4,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":96681,"text":"func","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":96682,"text":"->","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":96683,"text":"return","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":96684,"text":"in","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to define a function that takes an array of Integers as a parameter and returns it, sorted in descending order.\r\n[!raw!]\r\n{0} order(arr: [Int]) {1} [Int] {\r\n{2} arr.sort({\r\nn1, n2 {3} n1 > n2\r\n})\r\n}","textContent":"[h1]Inferring Type from Context[/h1]\r\n\r\nThe sorting closure is passed as an argument to a function, making it possible for Swift to infer the types of its parameters and the type of the return value from the type of the sort method's second parameter. This parameter expects a function of type[b] (String, String) -> Bool[/b]. This means that writing the (String, String) and Bool types as part of the closure expression's definition is not necessary. Because all of the types can be inferred, the return arrow (->) and the parentheses around the names of the parameters can also be omitted:[code format=\"swift\"]reversed = names.sort( { s1, s2 in return s1 > s2 } )[/code]\r\nThe parameter types and return type can always be inferred when passing a closure to a function as an inline closure expression. As a result, it is unnecessary to write an inline closure in its fullest form when the closure is used as a function argument.\r\n[note]You still have the option of writing out the types. In fact, doing so is encouraged when you need to avoid ambiguity for others who might read your code.[/note]"},{"id":4928,"number":5,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":96685,"text":"{","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":96686,"text":"in","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":96687,"text":"}","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks:\r\n[!raw!]\r\na = b.sort( {0} s1, s2 {1} s1 > s2 {2} )","textContent":"[h1]Inferring Type from Context [/h1]\r\n\r\n[b]Single-expression[/b] closures can implicitly return the result of their single expression, simply by omitting the [i]return [/i]keyword from the declaration, as in this new version of the previous example:[code format=\"swift\"]reversed = names.sort( { s1, s2 in s1 > s2 } )[/code]\r\nHere, the function type of the [b]sort [/b]method's second argument makes it clear that a Bool value must be returned by the closure.\r\n[note]Because the closure's body contains a single expression [b](s1 > s2)[/b] that returns a Bool value, there is no ambiguity, and the [b]return [/b]keyword can be omitted.[/note]"},{"id":4805,"number":6,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":2,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":96688,"text":"a","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"What is the output of the following code?\r\nlet names = [\"c\", \"a\", \"e\", \"b\"]\r\nlet res = names.sort(<)\r\nprint(res[0])","textContent":"[h1]Shorthand Argument Names[/h1]\r\n\r\nSwift automatically provides shorthand argument names for inline closures. These argument names can be used to refer to the values of the closure's arguments, with the names [b]$0[/b], [b]$1[/b], [b]$2[/b], and so on.\r\n\r\nIf you use these shorthand argument names within your closure expression, you can omit the closure's argument list from its definition, and the number and type of the shorthand argument names will be inferred from the expected function type. The [b]in [/b]keyword can also be omitted, since the closure expression is entirely made up of its body:\r\n[code format=\"swift\"]reversed = names.sort( { $0 > $1 } )[/code]\r\nHere, $0 and $1 refer to the closure's first and second String arguments.\r\n\r\n[h2]Operator Functions[/h2]\r\n\r\nThere's actually an even shorter way to write the closure expression above. Swift's String type defines its string-specific implementation of the greater-than operator (>) as a function that has two parameters of type String, and returns a value of type Bool. This exactly matches the function type needed for the sort method's second parameter. Just pass in the greater-than operator, and Swift will then infer that you want to use its string-specific implementation:[code format=\"swift\"]reversed = names.sort([b]>[/b])[/code]"}]}}