{"lesson":{"id":2479,"name":"Special Sequences","type":0,"mode":1,"videoID":null,"tags":"regular-expressions","quizzes":[{"id":5173,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":104682,"text":"\"abc\" or \"xyz\", followed by the same thing","isCorrect":true,"properties":{}},{"id":104683,"text":"\"abc\", then \"xyz\"","isCorrect":false,"properties":{}},{"id":104684,"text":"\"abc\" or \"xyz\", then a \"1\"","isCorrect":false,"properties":{}}],"question":"What would (abc|xyz)\\1 match?","textContent":"[h1]Special Sequences[/h1]\r\n\r\nThere are various [b]special sequences[/b] you can use in regular expressions. They are written as a backslash followed by another character. \r\nOne useful special sequence is a backslash and a number between 1 and 99, e.g., \\1 or \\17. This matches the expression of the group of that number.\r\n[b]Example:[/b] [code format=\"py\" codeId=\"438\"]import re\r\n\r\n[b]pattern = r\"(.+) \\1\"[/b]\r\n\r\nmatch = re.match(pattern, \"word word\")\r\nif match:\r\n   print (\"Match 1\")\r\n\r\nmatch = re.match(pattern, \"?! ?!\")\r\nif match:\r\n   print (\"Match 2\")    \r\n\r\nmatch = re.match(pattern, \"abc cde\")\r\nif match:\r\n   print (\"Match 3\")[/code]\r\n[b]Result:[/b] [code format=\"raw\" ]>>>\r\nMatch 1\r\nMatch 2\r\n>>>[/code]\r\n[note]Note, that \"[b](.+) \\1[/b]\" is not the same as \"[b](.+) (.+)[/b]\", because [b]\\1[/b] refers to the first group's subexpression, which is the matched expression itself, and not the regex pattern.[/note]"},{"id":5174,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":104685,"text":"[1-6!]","isCorrect":false,"properties":{}},{"id":104686,"text":"(\\d*\\W)+","isCorrect":false,"properties":{}},{"id":104687,"text":"(\\D+\\s?)+","isCorrect":true,"properties":{}}],"question":"Which pattern would NOT match \"123!456!\"?","textContent":"[h1]Special Sequences[/h1]\r\n\r\nMore useful special sequences are [b]\\d[/b], [b]\\s[/b], and [b]\\w[/b].\r\nThese match [b]digits[/b], [b]whitespace, [/b]and [b]word characters[/b] respectively. \r\nIn ASCII mode they are equivalent to [0-9], [ \\t\\n\\r\\f\\v], and [a-zA-Z0-9_].\r\nIn Unicode mode they match certain other characters, as well. For instance, [b]\\w[/b] matches letters with accents.\r\nVersions of these special sequences with upper case letters - [b]\\D[/b], [b]\\S[/b], and [b]\\W[/b] - mean the opposite to the lower-case versions. For instance, [b]\\D[/b] matches anything that isn't a digit.\r\n[b]Example:[/b] [code format=\"py\" codeId=\"439\"]import re\r\n\r\npattern = [b]r\"(\\D+\\d)\"[/b]\r\n\r\nmatch = re.match(pattern, \"Hi 999!\")\r\n\r\nif match:\r\n   print(\"Match 1\")\r\n\r\nmatch = re.match(pattern, \"1, 23, 456!\")\r\nif match:\r\n   print(\"Match 2\")\r\n\r\nmatch = re.match(pattern, \" ! $?\")\r\nif match:\r\n    print(\"Match 3\")[/code]\r\n[b]Result:[/b] [code format=\"raw\" ]>>>\r\nMatch 1\r\n>>>[/code]\r\n[note][b](\\D+\\d)[/b] matches one or more non-digits followed by a digit.[/note]"},{"id":5175,"number":3,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":104688,"text":"\\AS...\\b.\\Z","isCorrect":true,"properties":{}},{"id":104689,"text":"\\ASPAM\\Z","isCorrect":false,"properties":{}},{"id":104690,"text":"SP\\AM!\\Z","isCorrect":false,"properties":{}}],"question":"Which pattern would match 'SPAM!' in a search?","textContent":"[h1]Special Sequences[/h1]\r\n\r\nAdditional special sequences are [b]\\A[/b], [b]\\Z[/b], and [b]\\b[/b].\r\nThe sequences [b]\\A[/b] and [b]\\Z[/b] match the beginning and end of a string, respectively. \r\nThe sequence [b]\\b[/b] matches the empty string between [b]\\w[/b] and [b]\\W[/b] characters, or [b]\\w[/b] characters and the beginning or end of the string. Informally, it represents the boundary between words.\r\nThe sequence [b]\\B[/b] matches the empty string anywhere else.\r\n[b]Example:[/b] [code format=\"py\" codeId=\"440\"]import re\r\n\r\n[b]pattern = r\"\\b(cat)\\b\"[/b]\r\n\r\nmatch = re.search(pattern, \"The cat sat!\")\r\nif match:\r\n   print (\"Match 1\")\r\n\r\nmatch = re.search(pattern, \"We s>cat<tered?\")\r\nif match:\r\n   print (\"Match 2\")\r\n\r\nmatch = re.search(pattern, \"We scattered.\")\r\nif match:\r\n   print (\"Match 3\")[/code]\r\n[b]Result:[/b] [code format=\"raw\" ]>>>\r\nMatch 1\r\nMatch 2\r\n>>>[/code]\r\n[note]\"[b]\\b(cat)\\b[/b]\" basically matches the word \"[b]cat\"[/b] surrounded by word boundaries.[/note]"}]}}