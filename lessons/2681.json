{"lesson":{"id":2681,"name":"Polymorphism","type":0,"mode":1,"videoID":null,"tags":"polymorphism","quizzes":[{"id":5564,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":103959,"text":"one method with different implementations","isCorrect":true,"properties":{}},{"id":103960,"text":"one implementation with different methods","isCorrect":false,"properties":{}},{"id":103961,"text":"each implementation in a different method","isCorrect":false,"properties":{}}],"question":"Briefly, polymorphism is:","textContent":"[h1]Polymorphism[/h1]\r\n\r\nThe word [b]polymorphism[/b] means \"having many forms\". \r\nTypically, polymorphism occurs when there is a hierarchy of classes and they are related through inheritance from a common base class.\r\nPolymorphism means that a call to a member method will cause a different implementation to be executed depending on the [b]type[/b] of object that invokes the method. \r\n[note]Simply, polymorphism means that a single method can have a number of different implementations.[/note]"},{"id":5565,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":103971,"text":"class","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":103972,"text":"public","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":103973,"text":"virtual","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to define a public and virtual method Bark in the Animal class:\r\n[!raw!]\r\n{0} Animal {\r\n  {1} {2} void Bark() {\r\n    Console.Write(\"Barking.\");\r\n  }\r\n}","textContent":"[h1]Polymorphism[/h1]\r\n\r\nConsider having a program that allows users to draw different shapes. Each shape is drawn differently, and you do not know which shape the user will choose. \r\nHere, polymorphism can be leveraged to invoke the appropriate [b]Draw[/b] method of any derived class by overriding the same method in the base class. Such methods must be declared using the [b]virtual[/b] keyword in the base class.\r\n[b]For example:[/b] [code format=\"cs\" ]class Shape {\r\n  public [b]virtual [/b]void Draw() {\r\n    Console.Write(\"Base Draw\");\r\n  }\r\n}[/code]\r\nThe [b]virtual[/b] keyword allows methods to be overridden in derived classes.\r\n[note]Virtual methods enable you to work with groups of related objects in a uniform way.[/note]"},{"id":5566,"number":3,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":103989,"text":":","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":103990,"text":"override","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":103991,"text":"()","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to implement the Bark method in the Dog class:\r\n[!raw!]\r\nclass Dog {0} Animal {\r\n  public {1} void Bark{2} {\r\n    Console.WriteLine(\"Woof!\");\r\n  }\r\n}","textContent":"[h1]Polymorphism[/h1]\r\n\r\nNow, we can derive different shape classes that define their own [b]Draw[/b] methods using the [b]override[/b] keyword: [code format=\"cs\" ]class Circle : Shape {\r\n  public [b]override[/b] void [b]Draw[/b]() {\r\n    // draw a circle...\r\n    Console.WriteLine(\"Circle Draw\");\r\n  }\r\n}\r\nclass Rectangle : Shape {\r\n  public [b]override[/b] void [b]Draw[/b]() {\r\n    // draw a rectangle...\r\n    Console.WriteLine(\"Rect Draw\");\r\n  }\r\n}[/code]\r\nThe virtual Draw method in the Shape base class can be overridden in the derived classes. In this case, Circle and Rectangle have their own Draw methods.\r\nNow, we can create separate Shape objects for each derived type and then call their Draw methods: [code format=\"cs\" codeId=\"901\"]static void Main(string[] args) {\r\n  Shape c = new Circle();\r\n  c.Draw();\r\n  //Outputs \"Circle Draw\"\r\n\r\n  Shape r = new Rectangle();\r\n  r.Draw();\r\n  //Outputs \"Rect Draw\"\r\n}[/code]\r\n[note]As you can see, each object invoked its own [b]Draw[/b] method, thanks to polymorphism.[/note]"},{"id":5567,"number":4,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":104008,"text":"a","isCorrect":false,"properties":{}},{"id":104009,"text":"b","isCorrect":false,"properties":{}},{"id":104010,"text":"ab","isCorrect":true,"properties":{}},{"id":104011,"text":"ba","isCorrect":false,"properties":{}}],"question":"Class B inherits from class A. The constructor of class A displays \"a\", while the class B constructor displays \"b\".\r\nWhat is output to the screen when the code A a = new B(); is run?","textContent":"[h1]Polymorphism[/h1]\r\n\r\nTo summarize, [b]polymorphism[/b] is a way to call the same method for different objects and generate different results based on the object type. This behavior is achieved through virtual methods in the base class.\r\nTo implement this, we create objects of the base type, but instantiate them as the derived type: [code format=\"cs\" ][b]Shape [/b]c = new [b]Circle[/b]();[/code]\r\n[b]Shape [/b]is the base class. [b]Circle [/b]is the derived class.\r\nSo why use polymorphism? We could just instantiate each object of its type and call its method, as in: [code format=\"cs\" ][b]Circle [/b]c = new [b]Circle[/b]();\r\nc.Draw();[/code]\r\nThe polymorphic approach allows us to treat each object the same way. As all objects are of type Shape, it is easier to maintain and work with them. You could, for example, have a list (or array) of objects of that type and work with them dynamically, without knowing the actual derived type of each object.\r\n[note]Polymorphism can be useful in many cases. For example, we could create a game where we would have different Player types with each Player having a separate behavior for the Attack method. \r\nIn this case, Attack would be a virtual method of the base class Player and each derived class would override it.[/note]"}]}}