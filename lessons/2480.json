{"lesson":{"id":2480,"name":"Groups","type":0,"mode":1,"videoID":null,"tags":"regular-expressions","quizzes":[{"id":5169,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":104671,"text":"One or more repetitions of a non-vowel, a vowel and a non-vowel","isCorrect":true,"properties":{}},{"id":104672,"text":"Nothing","isCorrect":false,"properties":{}},{"id":104673,"text":"A number of repetitions of \"aeiou\" that is a multiple of three","isCorrect":false,"properties":{}}],"question":"What would '([^aeiou][aeiou][^aeiou])+' match?","textContent":"[h1]Groups[/h1]\r\n\r\nA group can be created by surrounding part of a regular expression with [b]parentheses[/b]. \r\nThis means that a group can be given as an argument to metacharacters such as * and ?.\r\n[b]Example:[/b] [code format=\"py\" codeId=\"434\"]import re\r\n\r\n[b]pattern = r\"egg(spam)*\"[/b]\r\n\r\nif re.match(pattern, \"egg\"):\r\n   print(\"Match 1\")\r\n\r\nif re.match(pattern, \"eggspamspamspamegg\"):\r\n   print(\"Match 2\")\r\n\r\nif re.match(pattern, \"spam\"):\r\n   print(\"Match 3\")[/code]\r\n[b](spam)[/b] represents a group in the example pattern shown above.\r\n[b]Result:[/b] [code format=\"raw\" ]>>>\r\nMatch 1\r\nMatch 2\r\n>>>[/code]"},{"id":5170,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":104674,"text":"0","isCorrect":false,"properties":{}},{"id":104675,"text":"45678","isCorrect":false,"properties":{}},{"id":104676,"text":"56","isCorrect":true,"properties":{}},{"id":104677,"text":"23","isCorrect":false,"properties":{}}],"question":"What would group(3) be of a match of 1(23)(4(56)78)9(0)?","textContent":"[h1]Groups[/h1]\r\n\r\nThe content of groups in a match can be accessed using the [b]group[/b] function.\r\nA call of [b]group(0)[/b] or [b]group()[/b] returns the whole match. \r\nA call of [b]group(n),[/b] where [b]n[/b] is greater than 0, returns the [b]n[/b]th group from the left. \r\nThe method [b]groups()[/b] returns all groups up from 1.\r\n[b]Example:[/b] [code format=\"py\" codeId=\"435\"]import re\r\n\r\n[b]pattern = r\"a(bc)(de)(f(g)h)i\"[/b]\r\n\r\nmatch = re.match(pattern, \"abcdefghijklmnop\")\r\nif match:\r\n   print(match.group())\r\n   print(match.group(0))\r\n   print(match.group(1))\r\n   print(match.group(2))\r\n   print(match.groups())[/code]\r\n[b]Result:[/b] [code format=\"raw\" ]>>>\r\nabcdefghi\r\nabcdefghi\r\nbc\r\nde\r\n('bc', 'de', 'fgh', 'g')\r\n>>>[/code]\r\n[note]As you can see from the example above, groups can be nested. [/note]"},{"id":5171,"number":3,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":2,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":104678,"text":"3","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"What would be the result of len(match.groups()) of a match of (a)(b(?:c)(d)(?:e))?","textContent":"[h1]Groups[/h1]\r\n\r\nThere are several kinds of special groups. \r\nTwo useful ones are [b]named groups[/b] and [b]non-capturing groups[/b].\r\n[b]Named groups[/b] have the format [b](?P<name>...)[/b], where [b]name [/b]is the name of the group, and [b]...[/b] is the content. They behave exactly the same as normal groups, except they can be accessed by[b] group(name)[/b] in addition to its number.\r\n[b]Non-capturing groups[/b] have the format [b](?:...)[/b]. They are not accessible by the group method, so they can be added to an existing regular expression without breaking the numbering.\r\n[b]Example:[/b] [code format=\"py\" codeId=\"436\"]import re\r\n\r\n[b]pattern = r\"(?P<first>abc)(?:def)(ghi)\"[/b]\r\n\r\nmatch = re.match(pattern, \"abcdefghi\")\r\nif match:\r\n   print(match.group(\"[b]first[/b]\"))\r\n   print(match.groups())[/code]\r\n[b]Result:[/b] [code format=\"raw\" ]>>>\r\nabc\r\n('abc', 'ghi')\r\n>>>[/code]"},{"id":5172,"number":4,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":104679,"text":"(1|2|3|4|5)","isCorrect":false,"properties":{}},{"id":104680,"text":"[12345]","isCorrect":false,"properties":{}},{"id":104681,"text":"[1-6]","isCorrect":true,"properties":{}}],"question":"What regex is not equivalent to the others?","textContent":"[h1]Metacharacters[/h1]\r\n\r\nAnother important metacharacter is [b]|[/b].\r\nThis means \"or\", so [b]red|blue[/b] matches either \"red\" or \"blue\".\r\n[b]Example:[/b] [code format=\"py\" codeId=\"437\"]import re\r\n\r\n[b]pattern = r\"gr(a|e)y\"[/b]\r\n\r\nmatch = re.match(pattern, \"gray\")\r\nif match:\r\n   print (\"Match 1\")\r\n\r\nmatch = re.match(pattern, \"grey\")\r\nif match:\r\n   print (\"Match 2\")    \r\n\r\nmatch = re.match(pattern, \"griy\")\r\nif match:\r\n    print (\"Match 3\")[/code]\r\n[b]Result:[/b] [code format=\"raw\" ]>>>\r\nMatch 1\r\nMatch 2\r\n>>>[/code]"}]}}