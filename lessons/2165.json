{"lesson":{"id":2165,"name":"Overriding & Overloading","type":0,"mode":1,"videoID":"zN9pKULyoj4","tags":"polymorphism","quizzes":[{"id":4274,"number":1,"videoStart":21.0,"videoEnd":98.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":117887,"text":"True","isCorrect":true,"properties":{}},{"id":117888,"text":"False","isCorrect":false,"properties":{}}],"question":"Overridden methods should have the same return type and arguments.","textContent":"[h1]Method Overriding[/h1]\r\n\r\nAs we saw in the previous lesson, a subclass can define a behavior that's specific to the subclass type, meaning that a subclass can implement a parent class method based on its requirement.\r\nThis feature is known as method [b]overriding[/b].\r\n[b]Example:[/b] [code format=\"java\" codeId=\"775\"]class Animal {\r\n    public void makeSound() {\r\n        System.out.println(\"Grr...\");\r\n    }\r\n}\r\nclass Cat extends Animal {\r\n    [b]public void makeSound() [/b]{\r\n        System.out.println(\"Meow\");\r\n    }\r\n}[/code]\r\nIn the code above, the Cat class overrides the [b]makeSound[/b]() method of its superclass Animal.\r\n\r\n[b]Rules for Method Overriding:[/b]\r\n- Should have the [b]same [/b]return type and arguments\r\n- The[b] access level[/b] cannot be more restrictive than the overridden method's access level (Example: If the superclass method is declared public, the overriding method in the sub class can be neither private nor protected)\r\n- A method declared [b]final [/b]or [b]static [/b]cannot be overridden\r\n- If a method cannot be inherited, it cannot be overridden\r\n- Constructors cannot be overridden\r\n[note]Method overriding is also known as [b]runtime polymorphism[/b].[/note]"},{"id":4276,"number":2,"videoStart":98.0,"videoEnd":221.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":100260,"text":"A","isCorrect":false,"properties":{}},{"id":100261,"text":"B","isCorrect":true,"properties":{}},{"id":100262,"text":"Nothing","isCorrect":false,"properties":{}},{"id":100263,"text":"AB","isCorrect":false,"properties":{}}],"question":"What is the output of this code?\r\nclass A {\r\n   public void do() {\r\n     System.out.println(''A'');\r\n   }\r\n   public void do(String str) {\r\n     System.out.println(str);\r\n   }\r\n}\r\nclass B {\r\n   public static void main(String[ ] args) {\r\n   A object = new A();\r\n   object.do(''B'');\r\n   }\r\n}","textContent":"[h1]Method Overloading[/h1]\r\n\r\nWhen methods have the same name, but different parameters, it is known as method [b]overloading[/b].\r\nThis can be very useful when you need the same method functionality for different types of parameters.\r\nThe following example illustrates a method that returns the maximum of its two parameters. [code format=\"java\" ][b]int [/b]max([b]int [/b]a, [b]int [/b]b) {\r\n  if(a > b) {\r\n    return a;\r\n  }\r\n  else {\r\n    return b;\r\n  }\r\n}[/code]\r\nThe method shown above will only work for parameters of type [b]integer[/b].\r\nHowever, we might want to use it for [b]doubles[/b], as well. For that, you need to overload the [b]max [/b]method: [code format=\"java\" codeId=\"776\"][b]double [/b]max([b]double [/b]a, [b]double [/b]b) {\r\n  if(a > b) {\r\n    return a;\r\n  }\r\n  else {\r\n    return b;\r\n  }\r\n}[/code]\r\nNow, our [b]max [/b]method will also work with [b]doubles[/b].\r\nAn overloaded method [b]must [/b]have a different argument list; the parameters should differ in their type, number, or both. \r\n[note]Another name for method overloading is [b]compile-time polymorphism[/b].[/note]"}]}}