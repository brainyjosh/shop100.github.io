{"lesson":{"id":2357,"name":"Properties","type":0,"mode":1,"videoID":null,"tags":"properties","quizzes":[{"id":4821,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":96707,"text":"struct","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":96708,"text":"var","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":96709,"text":"var","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to declare a structure with two variable properties.\r\n[!raw!]\r\n{0} Point {\r\n{1} x: Int = 0\r\n{2} y: Int = 0\r\n}","textContent":"[h1]Properties[/h1]\r\n\r\n[b]Properties [/b]associate values with a particular class, structure, or enumeration. [b]Stored properties[/b] store constant and variable values as part of an instance.\r\nIn its simplest form, a [b]stored property[/b] is a [i]constant [/i]or [i]variable [/i]that is stored as part of an instance of a particular class or structure. [code format=\"swift\"]struct Size {\r\n   var width: Int \r\n   let height: Int \r\n}\r\nvar size1 = Size(width: 10, height: 35)\r\nsize1.width = 6[/code]\r\n[note]In the example above, [b]height [/b]is initialized when the new size is created. This is a [b]constant [/b]property, and it cannot be changed once initialized.\r\nWhen creating an instance of a structure, if you assign an instance of a structure to a [b]constant[/b], the instance's properties cannot be modified, even if they were declared as variable properties.[/note]"},{"id":4929,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":2,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":96710,"text":"lazy var","isCorrect":false,"properties":{"prefix":"","postfix":" uploader"}}],"question":"Fill in the blanks to declare a lazy property called \"uploader\".","textContent":"[h1]Lazy Stored Properties[/h1]\r\n\r\nA [b]lazy [/b]stored property's initial value is not calculated until the first time it is used.[code format=\"swift\"]class DataManager {\r\n   [b]lazy [/b]var importer = DataImporter()\r\n   var data = [String]()\r\n}[/code]\r\nLazy properties are useful when a property's initial value is dependent on outside factors, the values of which are not known until after an instance's initialization is complete; or when the initial value for a property requires complex or computationally expensive setup that should not be performed unless or until it is needed.\r\n[note]You must always declare a lazy property as a [b]variable[/b], using the [b]var [/b]keyword, because its initial value might not be retrieved until after the completion of instance initialization. [b]Constant [/b]properties must always have a value before initialization completes, and therefore cannot be declared as lazy.[/note]"},{"id":4822,"number":3,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":6,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":96711,"text":"get","isCorrect":true,"properties":{}},{"id":96712,"text":"return","isCorrect":true,"properties":{}},{"id":96713,"text":"Cuboid","isCorrect":true,"properties":{}},{"id":96714,"text":"volume","isCorrect":true,"properties":{}}],"question":"Fill in the blanks to declare a read-only volume property. Then create a Cuboid variable and print its volume property.\r\n[!raw!]\r\nstruct Cuboid {\r\n   var w = 0.0, h = 0.0, d = 0.0\r\n   var volume: Double {\r\n     {0} {\r\n       {1} w * h * d\r\n     }\r\n   }\r\n}\r\nvar c = {2}(w:2, h: 5, d: 3)\r\nprint(c.{3})","textContent":"[h1]Computed Properties[/h1]\r\n\r\n[b][/b]Rather than storing a value, a[b] computed property[/b] provides a [i]getter [/i]and, optionally, a [i]setter[/i], which indirectly retrieve and set other properties and values, respectively.[code format=\"swift\"]struct Point {\r\n   var x = 0.0, y = 0.0\r\n}\r\nstruct Shape {\r\n   var origin = Point()   \r\n   var center: Point {\r\n     [b]get [/b]{\r\n       return Point(x: origin.x/2 , y: origin.y/2)\r\n     }\r\n     [b]set[/b](newCenter) {\r\n       origin.x = newCenter.x/2\r\n       origin.y = newCenter.y/2\r\n     }\r\n   }\r\n}[/code]\r\nThe [b]Shape [/b]structure defines a custom [b]getter [/b]and [b]setter [/b]for a computed variable called [i]center[/i]. The [i]center[/i] property is then accessed through dot syntax, which causes the getter for [i]center [/i]to be called to retrieve the current property value. Rather than returning an existing value, the getter actually calculates and returns a new point that represents the center of the shape. \r\n\r\nIf a computed property's setter does not define a name for the new value to be set, a default name of [b]newValue [/b]is used.\r\nBelow is an alternative version of the [b]Rect [/b]structure, which takes advantage of this shorthand notation:\r\n[code format=\"swift\"]struct Point {\r\n   var x = 0.0, y = 0.0\r\n}\r\nstruct Shape {\r\n   var origin = Point()   \r\n   var center: Point {\r\n     get {\r\n      return Point(x: origin.x/2, y: origin.y/2)\r\n     }\r\n     set {\r\n      origin.x = [b]newValue[/b].x/2\r\n      origin.y = [b]newValue[/b].y/2\r\n     }\r\n  }\r\n}[/code]\r\n[note]A computed property with a getter but no setter is known as a [b]read-only computed property[/b]. It always returns a value, and can be accessed through dot syntax. However, that value cannot be altered.[/note]"},{"id":4823,"number":4,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":6,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":96715,"text":"newValue","isCorrect":true,"properties":{}},{"id":96716,"text":"didSet","isCorrect":true,"properties":{}},{"id":96717,"text":"oldValue","isCorrect":true,"properties":{}},{"id":96718,"text":"willSet","isCorrect":false,"properties":{}}],"question":"Fill in the blanks to define the property observers so that the new and old values are printed to the screen.\r\n[!raw!]\r\nclass MyCounter {\r\n var steps: Int = 0 {\r\n   willSet {\r\n     print({0})\r\n   }\r\n   {1} {\r\n      print({2})\r\n   }\r\n }\r\n}","textContent":"[h1]Property Observers[/h1]\r\n\r\n[b]Property observers[/b] detect and respond to changes in a property's value. Property observers are called every time a property's value is set, even if the new value is the same as the property's current value.\r\nProperty observers can be added to any defined stored properties, with the exception of lazy stored properties.\r\nYou have the option of defining either or both of the following observers of a property:\r\n- [b]willSet [/b]is called just before the value is stored.\r\n- [b]didSet [/b]is called immediately after the new value is stored.\r\n\r\nThe example below defines a new class called [b]StepCounter[/b], which tracks the total number of steps that a person takes while walking. [code format=\"swift\"]class StepCounter {\r\n var totalSteps: Int = 0 {\r\n   [b]willSet[/b]([b]newSteps[/b]) {\r\n     print(\"About to set totalSteps to \\(newSteps)\")\r\n   }\r\n   [b]didSet [/b]{\r\n     if totalSteps > [b]oldValue [/b] {\r\n       print(\"Added \\(totalSteps - oldValue) steps\")\r\n     }\r\n   }\r\n }\r\n}\r\nlet stepCounter = StepCounter()\r\nstepCounter.totalSteps = 50\r\n// About to set totalSteps to 50\r\n// Added 50 steps\r\nstepCounter.totalSteps = 150\r\n// About to set totalSteps to 150\r\n// Added 100 steps\r\nstepCounter.totalSteps = 420\r\n// About to set totalSteps to 420\r\n// Added 270 steps[/code]\r\nThe [b]StepCounter [/b]class declares a [i]totalSteps [/i]property of type Int, with [b]willSet [/b]and [b]didSet [/b]observers.\r\nThe willSet and didSet observers for [i]totalSteps [/i]are called whenever the property is assigned a new value. \r\nThe willSet observer uses a custom parameter name of [b]newSteps [/b]for the upcoming new value. \r\n\r\nThe [b]didSet [/b]observer is called after the value of [i]totalSteps [/i]is updated. It compares the new value of [i]totalSteps [/i]against the old value. The didSet observer does not provide a custom parameter name for the old value; the default name of [b]oldValue [/b]is used, instead.\r\nSimilarly, [b]newValue [/b]could be used for the willSet observer, if no parameter name was defined.\r\n[note]If you assign a value to a property within its own [b]didSet [/b]observer, the new assigned value will replace the one that was just set.[/note]"},{"id":4824,"number":5,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":2,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":96719,"text":"static","isCorrect":false,"properties":{"prefix":"","postfix":" var num = 0"}}],"question":"Fill in the blank to define a type property:","textContent":"[h1]Type Properties[/h1]\r\n\r\n[b]Type properties[/b] are useful when defining values that are universal to all instances of a particular type, such as a constant property used in all instances, or a variable property that stores a global value to all instances of that type. Stored type properties can be variables or constants. You define type properties with the [b]static [/b]keyword:\r\n[code format=\"swift\"]class SomeClass {\r\n   [b]static [/b]var storedProp = \"Some value.\"\r\n   [b]static [/b]var computedProp: Int {\r\n      return 42\r\n   }\r\n}[/code]\r\nType properties are queried and set with [i]dot syntax[/i], just like instance properties. However, type properties are queried and set on the [b]type[/b], not on an instance of that type: [code format=\"swift\"]print(SomeClass.storedProp) [/code]\r\n[note]Unlike stored instance properties, you must always give stored type properties a [b]default value[/b]. This is because the type itself does not have an initializer that can assign a value to a stored type property at initialization time.[/note]"}]}}