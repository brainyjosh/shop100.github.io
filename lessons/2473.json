{"lesson":{"id":2473,"name":"Class & Static Methods","type":0,"mode":1,"videoID":null,"tags":"classes","quizzes":[{"id":5142,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":104471,"text":"@classmethod","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":104472,"text":"def","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to make sayHi() a class method.\r\n[!raw!]\r\nclass Person:\r\n  def __init__(self, name):\r\n    self.name = name\r\n\r\n  {0}\r\n  {1} sayHi(cls):\r\n    print(\"Hi\")","textContent":"[h1]Class Methods[/h1]\r\n\r\nMethods of objects we've looked at so far are called by an instance of a class, which is then passed to the [b]self[/b] parameter of the method.\r\n[b]Class methods[/b] are different - they are called by a class, which is passed to the [b]cls[/b] parameter of the method. \r\nA common use of these are factory methods, which instantiate an instance of a class, using different parameters than those usually passed to the class constructor. \r\nClass methods are marked with a [b]classmethod decorator[/b].\r\n[b]Example:[/b][code format=\"py\" codeId=\"418\"]class Rectangle:\r\n  def __init__(self, width, height):\r\n    self.width = width\r\n    self.height = height\r\n\r\n  def calculate_area(self):\r\n    return self.width * self.height\r\n\r\n  [b]@classmethod\r\n  def new_square(cls, side_length):\r\n    return cls(side_length, side_length)[/b]\r\n\r\nsquare = [b]Rectangle.new_square(5)[/b]\r\nprint(square.calculate_area())[/code]\r\n[b]Result:[/b] [code format=\"raw\" ]>>>\r\n25\r\n>>>[/code]\r\n[b]new_square [/b]is a class method and is called on the class, rather than on an instance of the class. It returns a new object of the class [b]cls[/b].\r\n[note]Technically, the parameters [b]self [/b]and [b]cls [/b]are just conventions; they could be changed to anything else. However, they are universally followed, so it is wise to stick to using them.[/note]"},{"id":5143,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":98285,"text":"def spam(self, x, y):","isCorrect":false,"properties":{}},{"id":98286,"text":"def spam(cls, x, y):","isCorrect":false,"properties":{}},{"id":98287,"text":"def spam(x, y):","isCorrect":true,"properties":{}}],"question":"Which of these is most likely to be a static method?","textContent":"[h1]Static Methods[/h1]\r\n\r\n[b]Static methods[/b] are similar to class methods, except they don't receive any additional arguments; they are identical to normal functions that belong to a class. \r\nThey are marked with the [b]staticmethod [/b]decorator.\r\n[b]Example:[/b] [code format=\"py\" codeId=\"419\"]class Pizza:\r\n  def __init__(self, toppings):\r\n    self.toppings = toppings\r\n\r\n [b] @staticmethod[/b]\r\n  def validate_topping(topping):\r\n    if topping == \"pineapple\":\r\n      raise ValueError(\"No pineapples!\")\r\n    else:\r\n      return True\r\n\r\ningredients = [\"cheese\", \"onions\", \"spam\"]\r\nif all(Pizza.[b]validate_topping[/b](i) for i in ingredients):\r\n  pizza = Pizza(ingredients) [/code]\r\n[note]Static methods behave like plain functions, except for the fact that you can call them from an instance of the class. [/note]"}]}}