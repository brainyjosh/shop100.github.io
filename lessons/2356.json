{"lesson":{"id":2356,"name":"Classes vs. Structures","type":0,"mode":1,"videoID":null,"tags":"classes","quizzes":[{"id":4817,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":96703,"text":"res","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":96704,"text":"width","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to print the width property of the Resolution structure's instance.\r\n[!raw!]\r\nlet res = Resolution()\r\nprint({0}.{1})","textContent":"[h1]Structures are Value Types[/h1]\r\n\r\nA [b]value type[/b] is a type whose value is copied when it is assigned to a variable or constant, or when it is passed to a function.\r\nIn fact, all of the basic types in Swift - integers, floating-point numbers, Booleans, strings, arrays, and dictionaries - are value types, and are implemented as structures behind the scenes.\r\n\r\nAll Swift structures are [b]value types[/b]. This means that any structure instances you create - and any value types they have as properties - are always copied when they are passed around in your code.\r\n\r\nConsider this example, which uses the [b]Resolution [/b]structure from the previous example: [code format=\"swift\"]let hd = Resolution(width: 1920, height: 1080)\r\nvar cinema = hd[/code]\r\nThe example declares a constant called [b]hd [/b]and sets it to a [b]Resolution [/b]instance.\r\nIt then declares a variable called [i]cinema[/i], and sets it to the current value of [i]hd[/i]. Because Resolution is a structure, a copy of the existing instance is made, and this new copy is assigned to [i]cinema[/i]. Even though [i]hd [/i]and [i]cinema [/i]now have the same [i]width [/i]and [i]height[/i], behind the scenes they are two completely different instances.\r\n\r\nNext, the width property of [i]cinema [/i]is amended: [code format=\"swift\"]cinema.width = 2048[/code]\r\nHowever, the [i]width [/i]property of the original [i]hd [/i]instance still has the old value of 1920.[code format=\"swift\"]print(\"hd is still \\(hd.width) pixels wide\")\r\n// prints \"hd is still 1920 pixels wide\"[/code]\r\n[note]The same behavior is true of enumerations.[/note]"},{"id":4818,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":2,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":96705,"text":"42","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"What is the output of the following code?\r\nclass Test {\r\n   var num = 17\r\n}\r\nlet a = Test()\r\nlet b = a\r\nb.num = 42\r\nprint(a.num)","textContent":"[h1]Classes are Reference Types[/h1]\r\n\r\nUnlike value types, [b]reference types[/b] are not copied when assigned to a variable or constant, or when they are passed to a function. Rather than a copy, a reference to the existing instance is used instead.\r\nHere's an example, using the VideoMode class: [code format=\"swift\"]let tenEighty = VideoMode()\r\ntenEighty.resolution = hd\r\ntenEighty.interlaced = true\r\n\r\nlet alsoTenEighty = tenEighty\r\nalsoTenEighty.interlaced = false[/code]\r\nThe video mode is assigned a copy of the [i]hd [/i]resolution of 1920 by 1080 from before.\r\nNext, [b]tenEighty [/b]is assigned to a new constant, named [b]alsoTenEighty[/b], and the [i]interlaced [/i]property of [b]alsoTenEighty [/b]is modified.\r\nBecause classes are reference types, [b]tenEighty [/b]and [b]alsoTenEighty [/b]actually both refer to the same VideoMode instance, so the interlaced value is changed for both. Effectively, they are just two different names for the same single instance.\r\n[note]Rather than being declared as variables, [b]tenEighty [/b]and [b]alsoTenEighty [/b]are declared as constants. However, it's still possible to change their properties, because the values of the [b]tenEighty [/b]and [b]alsoTenEighty [/b]constants themselves do not actually change.[/note]"},{"id":4819,"number":3,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":96706,"text":"===","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blank to determine whether both variables refer to the same instance.\r\n[!raw!]\r\nif a {0} b {\r\n   print(\"Yes\")\r\n}","textContent":"[h1]Identity Operators[/h1]\r\n\r\nYou may need to determine whether two constants or variables refer to the same instance of a class. To accomplish this, Swift provides the following identity operators:\r\n[b]Identical to (===)[/b]\r\n[b]Not identical to (!==)[/b]\r\n\r\nUse these operators to check your constants or variables to see if they refer to the same single instance:[code format=\"swift\"]if tenEighty === alsoTenEighty {\r\n print(\"Same\")\r\n}[/code]\r\n[note]Note that \"identical to\" (represented by three equals signs, or ===) does not mean the same thing as \"equal to\" (represented by two equals signs, or ==).[/note]"},{"id":4820,"number":4,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":59743,"text":"Structure","isCorrect":true,"properties":{}},{"id":59744,"text":"Class","isCorrect":false,"properties":{}},{"id":59745,"text":"Enumeration","isCorrect":false,"properties":{}}],"question":"Which implementation is most appropriate for a point in a 3D coordinate system, having x, y, and z properties, each of type Double?","textContent":"[h1]Classes vs. Structures[/h1]\r\n\r\nStructure instances are always passed by [b]value[/b], and class instances are always passed by [b]reference[/b]. This means that they are suited to different kinds of tasks. \r\nAs a general guideline, consider creating a structure instead of a class when one or more of these conditions apply:\r\n\r\n1. The structure's primary purpose is to encapsulate a few relatively simple data values.\r\n2. It is reasonable to expect that the encapsulated values will be copied rather than referenced when you assign or pass around an instance of that structure.\r\n3. Any properties stored by the structure are themselves value types, which you would also expect to be copied, as opposed to being referenced.\r\n4. It is not necessary for the structure to inherit properties or behavior from another existing type.\r\n\r\nFor example, the [b]size of a geometric shape[/b] would be a good choice for a structure, with the structure perhaps encapsulating a [i]width [/i]property and a [i]height [/i]property, both of type [i]Double[/i].\r\n\r\nIn all other cases, define a class. You will find that most custom data constructs should be defined as classes rather than as structures.\r\n[note]Swift's [b]String[/b], [b]Array[/b], and [b]Dictionary [/b]types are implemented as structures.[/note]"}]}}