{"lesson":{"id":2448,"name":"Working with Files","type":0,"mode":1,"videoID":null,"tags":"files","quizzes":[{"id":5059,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":95930,"text":"Yes","isCorrect":true,"properties":{}},{"id":95931,"text":"No","isCorrect":false,"properties":{}}],"question":"Will the close() function get called in this code?\r\ntry:\r\n  f = open(\"filename.txt\")\r\n  print(f.read())\r\n  print(1 / 0)\r\nfinally:\r\n  f.close()","textContent":"[h1]Working with Files[/h1]\r\n\r\nIt is good practice to avoid wasting resources by making sure that files are always closed after they have been used. One way of doing this is to use [b]try [/b]and [b]finally[/b].[code format=\"py\"][b]try:[/b]\r\n   f = open(\"filename.txt\")\r\n   print(f.read())\r\n[b]finally:[/b]\r\n   f.close()[/code]\r\n[note]This ensures that the file is always closed, even if an error occurs.[/note]"},{"id":5060,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":104435,"text":"with","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":104436,"text":"as","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":104437,"text":"read","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to create a valid with statement, reading the contents of the file.\r\n[!raw!]\r\n{0} open(\"test.txt\") {1} f:\r\n  print(f.{2}())","textContent":"[h1]Working with Files[/h1]\r\n\r\nAn alternative way of doing this is using [b]with[/b] statements. This creates a temporary variable (often called [b]f[/b]),  which is only accessible in the indented block of the [b]with[/b] statement. [code format=\"py\" ][b]with [/b]open(\"filename.txt\") [b]as[/b] f:\r\n   print(f.read())[/code]\r\n[note]The file is automatically closed at the end of the [b]with [/b]statement, even if exceptions occur within it.[/note]"}]}}