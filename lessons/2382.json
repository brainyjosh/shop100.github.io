{"lesson":{"id":2382,"name":"Persist Data","type":0,"mode":1,"videoID":null,"tags":null,"quizzes":[{"id":4891,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":6,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":96796,"text":"class","isCorrect":true,"properties":{}},{"id":96797,"text":"NSCoding","isCorrect":true,"properties":{}},{"id":96798,"text":"NSEncoding","isCorrect":false,"properties":{}},{"id":96799,"text":"NSFiles","isCorrect":false,"properties":{}},{"id":96800,"text":"Test","isCorrect":false,"properties":{}}],"question":"Inherit the Test class from the protocol required to perform encoding and decoding functions.\r\n[!raw!]\r\n{0} Test: NSObject, {1}","textContent":"[h1]Persist Data[/h1]\r\n\r\nData persistence is one of the most important and common issues in iOS app development. \r\nCurrently, our data is reset every time we reopen the app, because we haven't implemented data persistence.\r\nTo be able to encode and decode itself and its properties, the Item class needs to conform to to the [b]NSCoding[/b] protocol. To conform to NSCoding, the Item needs to subclass [b]NSObject[/b]. \r\nIn [i]Item.swift[/i], find the class line and adopt the protocol: [code format=\"swift\"]class Item: NSObject, NSCoding {[/code]\r\nThe NSCoding protocol declares two methods that any class that adopts to it must implement so that instances of that class can be encoded and decoded: [code format=\"swift\"]func [b]encodeWithCoder[/b](aCoder: NSCoder)\r\n[b]init[/b](coder aDecoder: NSCoder)[/code]The [b]encodeWithCoder[/b]() method prepares the class's information to be archived, and the initializer unarchives the data when the class is created. You need to implement both the encodeWithCoder(_:) method and the initializer for the data to save and load properly. The [b]encodeWithCoder()[/b] method should look like this: [code format=\"swift\"]func encodeWithCoder(aCoder: NSCoder) {\r\n  aCoder.encodeObject(name, forKey: \"name\")\r\n}[/code]\r\nAdd the required initializer:[code format=\"swift\"]required convenience init?(coder aDecoder: NSCoder) {\r\n  let name = aDecoder.decodeObjectForKey(\"name\") as! String\r\n  self.init(name: name)\r\n}[/code]\r\nThe question mark (?) means that this is a failable initializer, and it may return nil.\r\nBecause the other initializer you defined on the Item class, [b]init?(name)[/b], is a designated initializer, its implementation needs to call to its superclass's initializer - to do that, add [b]super.init()[/b] to it: [code format=\"swift\"]init?(name: String) {\r\n   self.name = name\r\n   [b]super.init()[/b]\r\n}[/code]"},{"id":4892,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":2,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":60351,"text":"static","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"To  apply a property to the class, instead of an instance, the following keyword is used:","textContent":"[h1]Saving Data[/h1]\r\n\r\nThe next step is to create a persistent [b]path [/b]on the file system, where data will be saved and loaded.[code format=\"raw\"]static let Dir = NSFileManager().URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask).first!\r\n\r\nstatic let ArchiveURL = Dir.URLByAppendingPathComponent(\"items\")[/code]\r\nYou mark these constants with the [b]static [/b]keyword, which means they apply to the class instead of an instance of the class. Outside of the Item class, you'll access the path using the syntax [b]Item.ArchiveURL[/b].\r\nNow that you can save and load an individual item, you need to save and load the items list whenever a user adds, edits, or removes an item.\r\nTo implement the method to save the items list, in [i]ItemTableViewController.swift[/i] add the following method: [code format=\"raw\"]func [b]saveItems()[/b] {\r\n   let isSaved = NSKeyedArchiver.archiveRootObject(items, toFile: Item.ArchiveURL.path!)\r\n   if !isSaved {\r\n     print(\"Failed to save items...\")\r\n   }\r\n}[/code]\r\nThis method attempts to archive the items array to a specific location, and returns true if successful. [note]It uses the constant [b]ArchiveURL[/b], which was defined in the Item class to identify a location for saving the information.[/note]\r\nTo save the items list when a user adds, removes, or edits an item, you need to call the [b]saveItems()[/b] method in [b]unwindToList() - [/b]after the else clause, but inside of the outer if statement,[b] [/b]and in [b]tableView(_:commitEditingStyle:forRowAtIndexPath:) [/b]- after the [i]items.removeAtIndex(indexPath.row)[/i] line.\r\n[note]This code saves the items array whenever an item is deleted.[/note]"},{"id":4893,"number":3,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":2,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":61345,"text":"?","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Which symbol allows you to define a return value for a method that can be nil?","textContent":"[h1]Loading Data[/h1]\r\n\r\nNow, implement a method to load saved items in [i]ItemTableViewController.swift[/i]: [code format=\"raw\"]func [b]loadItems[/b]() -> [Item]? {\r\n   return NSKeyedUnarchiver.unarchiveObjectWithFile(\r\n      Item.ArchiveURL.path!) as? [Item]\r\n}[/code]\r\nThis method attempts to unarchive the object stored at the path [i]Item.ArchiveURL[/i] and to downcast that object to an array of Item objects.\r\n\r\nTo load the items list at the appropriate time, find the [b]viewDidLoad()[/b] method in [i]ItemTableViewController.swift[/i], and modify it to:[code format=\"raw\"]override func viewDidLoad() {\r\n  super.viewDidLoad()\r\n\r\n  navigationItem.leftBarButtonItem = editButtonItem()\r\n    \r\n  // Load saved items\r\n  [b]if let savedItems = loadItems() {\r\n    items += savedItems\r\n  }[/b]\r\n\r\n}[/code]\r\nThis will try to load the items from the file and add them to the items array.\r\nRun your app, add a few new items, and quit the app. The newly added items will be there the next time you open the app.  [img id=\"2065\" width=\"60%\"] \r\n[note]Congratulations! Now you have a functional ToDo List App.[/note]"}]}}