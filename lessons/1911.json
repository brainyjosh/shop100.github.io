{"lesson":{"id":1911,"name":"Virtual Functions","type":0,"mode":1,"videoID":"DudHooleNVg","tags":"polymorphism","quizzes":[{"id":3774,"number":1,"videoStart":201.0,"videoEnd":299.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":95204,"text":"class","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":95205,"text":"virtual","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to declare a virtual function named ''attack()'' for the ''Enemy'' class.\r\n[!raw!]\r\n{0} Enemy {\r\npublic:\r\n  {1} void attack() {\r\n     cout << \"enemy attacks\"; }\r\n};","textContent":"[h1]Virtual Functions[/h1]\r\n\r\nThe previous example demonstrates the use of base class pointers to the derived classes. Why is that useful? Continuing on with our game example, we want every Enemy to have an [b]attack()[/b] function. \r\nTo be able to call the corresponding attack() function for each of the derived classes using Enemy pointers, we need to declare the base class function as [b]virtual[/b].\r\nDefining a virtual function in the base class, with a corresponding version in a derived class, allows polymorphism to use Enemy pointers to call the derived classes' functions.\r\nEvery derived class will override the attack() function and have a separate implementation:[code format=\"cpp\"]class Enemy {\r\n public:\r\n  [b]virtual [/b]void attack() {\r\n  }\r\n};\r\n\r\nclass Ninja: public Enemy {\r\n public:\r\n  void attack() {\r\n   cout << \"Ninja!\"<<endl;\r\n  }\r\n};\r\n\r\nclass Monster: public Enemy {\r\n public:\r\n  void attack() {\r\n   cout << \"Monster!\"<<endl;\r\n }\r\n};[/code]\r\n[note]A virtual function is a base class function that is declared using the keyword [b]virtual[/b].[/note]"},{"id":3775,"number":2,"videoStart":300.0,"videoEnd":390.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":97866,"text":"virtual","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":97867,"text":"class","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":97868,"text":"public","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":97869,"text":"attack","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to declare an ''Enemy'' class with attack virtual function, and then declare a ''Ninja'' class that inherits from the ''Enemy'' and overrides its attack virtual function.\r\n[!raw!]\r\nclass Enemy {\r\npublic:\r\n {0} void attack() { \r\n  cout << \"Enemy attacks\"; }\r\n};\r\n{1} Ninja : {2} Enemy {\r\npublic:\r\n void {3}() {\r\n   cout << \"Ninja attacks\"; }\r\n};","textContent":"[h1]Virtual Functions[/h1]\r\n\r\nNow, we can use [b]Enemy [/b]pointers to call the [b]attack()[/b] function.[code format=\"cpp\" codeId=\"271\"]int main() {\r\n  Ninja n;\r\n  Monster m;\r\n  Enemy *e1 = &n;\r\n  Enemy *e2 = &m;\r\n\r\n  e1->attack();\r\n  e2->attack();\r\n}\r\n\r\n/* Output:\r\nNinja!\r\nMonster!\r\n*/[/code]\r\n[note]As the attack() function is declared virtual, it works like a template, telling that the derived class might have an [b]attack()[/b] function of its own.[/note]"},{"id":3776,"number":3,"videoStart":391.0,"videoEnd":504.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":101634,"text":"...it was declared using the keyword ''polymorphic''","isCorrect":false,"properties":{}},{"id":101635,"text":"...it has a virtual function","isCorrect":true,"properties":{}},{"id":101636,"text":"...it has a friend function","isCorrect":false,"properties":{}}],"question":"A class is called polymorphic if ...","textContent":"[h1]Virtual Functions[/h1]\r\n\r\nOur game example serves to demonstrate the concept of polymorphism; we are using [b]Enemy [/b]pointers to call the same [b]attack()[/b] function, and generating different results.[code format=\"cpp\" ]e1->attack();\r\ne2->attack();[/code]\r\nIf a function in the base class is [b]virtual[/b], the function's implementation in the derived class is called according to the actual type of the object referred to, regardless of the declared type of the pointer.\r\n[note]A class that declares or inherits a virtual function is called a [b]polymorphic [/b]class.[/note]"}]}}