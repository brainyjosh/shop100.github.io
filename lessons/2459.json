{"lesson":{"id":2459,"name":"Introduction","type":0,"mode":1,"videoID":null,"tags":"functions","quizzes":[{"id":5097,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":2,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":98191,"text":"16","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"What is the output of this code?\r\ndef test(func, arg):\r\n  return func(func(arg))\r\n\r\ndef mult(x):\r\n  return x * x\r\n\r\nprint(test(mult, 2))","textContent":"[h1]Functional Programming[/h1]\r\n\r\n[b]Functional programming[/b] is a style of programming that (as the name suggests) is based around functions. \r\nA key part of functional programming is [b]higher-order functions[/b]. We have seen this idea briefly in the previous lesson on functions as objects. Higher-order functions take other functions as arguments, or return them as results.\r\n[b]Example:[/b] [code format=\"py\" codeId=\"381\"]def apply_twice(func, arg):\r\n   return func(func(arg))\r\n\r\ndef add_five(x):\r\n   return x + 5\r\n\r\nprint(apply_twice(add_five, 10))[/code]\r\n[b]Result:[/b] [code format=\"raw\" ]>>>\r\n20\r\n>>>[/code]\r\n[note]The function [b]apply_twice [/b]takes another function as its argument, and calls it twice inside its body.[/note]"},{"id":5098,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":96022,"text":"Yes","isCorrect":true,"properties":{}},{"id":96023,"text":"No","isCorrect":false,"properties":{}},{"id":96024,"text":"It depends","isCorrect":false,"properties":{}}],"question":"Is this a pure function?\r\ndef func(x):\r\n  y = x**2\r\n  z = x + y\r\n  return z","textContent":"[h1]Pure Functions[/h1]\r\n\r\nFunctional programming seeks to use [b]pure functions[/b]. Pure functions have no side effects, and return a value that depends [b]only [/b]on their arguments.\r\nThis is how functions in math work: for example, The cos(x) will, for the same value of x, always return the same result.\r\nBelow are examples of pure and impure functions.\r\n[b]Pure function:[/b] [code format=\"py\"]def pure_function(x, y):\r\n  temp = x + 2*y\r\n  return temp / (2*x + y)[/code]\r\n[b]Impure function:[/b][code format=\"py\"]some_list = []\r\n\r\ndef impure(arg):\r\n  some_list.append(arg)[/code]\r\n[note]The function above is not pure, because it changed the state of [b]some_list[/b].[/note]"},{"id":5099,"number":3,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":106611,"text":"They are easier to run in parallel","isCorrect":false,"properties":{}},{"id":106612,"text":"They are easier to analyze","isCorrect":false,"properties":{}},{"id":106613,"text":"They are easier to write","isCorrect":true,"properties":{}}],"question":"Which of these is not an advantage of using pure functions?","textContent":"[h1]Pure Functions[/h1]\r\n\r\nUsing pure functions has both advantages and disadvantages. \r\nPure functions are:\r\n- easier to reason about and test.\r\n- more efficient. Once the function has been evaluated for an input, the result can be stored and referred to the next time the function of that input is needed, reducing the number of times the function is called. This is called [b]memoization[/b].\r\n- easier to run in parallel.\r\n[note]The main disadvantage of using only pure functions is that they majorly complicate the otherwise simple task of I/O, since this appears to inherently require side effects. \r\nThey can also be more difficult to write in some situations.[/note]"}]}}