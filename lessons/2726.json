{"lesson":{"id":2726,"name":"Procs","type":0,"mode":1,"videoID":null,"tags":"procs","quizzes":[{"id":5720,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":113502,"text":"new","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":113503,"text":"|","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":113504,"text":"+","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":113505,"text":"end","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":113506,"text":"call","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to create a Proc called sum that takes two parameters and outputs their sum. Call it for values 8 and 5.\r\n[!raw!]\r\nsum = Proc.{0} do |x, y{1}\r\n  puts x{2}y\r\n{3}\r\n\r\nputs sum.{4} 8, 5","textContent":"[h1]Procs[/h1]\r\n\r\nRuby provides the ability to take a block of code, wrap it up in an object (called a [b]proc[/b]), store it in a variable, and run the code in the block whenever you feel like (more than once, if you want). \r\n[b]For example:[/b] [code format=\"rb\" ]greet = [b]Proc[/b].new do |x|\r\n  puts \"Welcome #{x}\"\r\nend[/code]\r\nWe created a Proc that takes a parameter and outputs a greeting, and assigned it to the [b]greet [/b]variable.\r\nWe run the code in the proc using the [b]call [/b]method.[code format=\"rb\" codeId=\"1088\"]greet.[b]call [/b]\"David\"\r\ngreet.[b]call [/b]\"Amy\"\r\n\r\n# Outputs\r\n# \"Welcome David\"\r\n# \"Welcome Amy\"[/code]\r\n[note]The code between the [b]do [/b]and [b]end [/b]keywords can include any number of operations.[/note]"},{"id":5721,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":113511,"text":"Yes","isCorrect":true,"properties":{}},{"id":113512,"text":"No","isCorrect":false,"properties":{}}],"question":"Can you pass multiple procs to a method as arguments?","textContent":"[h1]Procs [/h1]\r\n\r\n[b]Procs [/b]are very similar to methods. They perform operations and can include parameters.\r\nWhat make Procs really powerful and unique is the ability to pass them into methods, because procs are actually objects.\r\n[b]For example:[/b] [code format=\"rb\" ]greet = Proc.new do |x|\r\n  puts \"Welcome #{x}\"\r\nend\r\n\r\ngoodbye = Proc.new do |x|\r\n  puts \"Goodbye #{x}\"\r\nend\r\n\r\ndef say(arr, proc)\r\n  arr.each { |x| proc.call x}\r\nend[/code]\r\nWe have defined two procs and a method, that takes an array and a proc as its parameters. For each item in the array it calls the proc. Now, [b]greet [/b]and [b]goodbye [/b]are objects that contain the corresponding blocks of code.\r\nWe can call the [b]say [/b]method and pass our proc objects as parameters: [code format=\"rb\" codeId=\"1089\"]people = [\"David\", \"Amy\", \"John\"]\r\nsay(people, greet)\r\nsay(people, goodbye)[/code]\r\nWe can pass to our methods as many procs as we want.\r\n[note]Using procs gives the added flexibility to be able to reuse code blocks in more than one place without having to type them out every time. Procs basically take blocks of code and embed them in an object, allowing them to be reused and passed around.[/note]"},{"id":5722,"number":3,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":6,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":113518,"text":"Proc","isCorrect":true,"properties":{}},{"id":113519,"text":"new","isCorrect":true,"properties":{}},{"id":113520,"text":"end","isCorrect":true,"properties":{}},{"id":113521,"text":"class","isCorrect":false,"properties":{}},{"id":113522,"text":"init","isCorrect":false,"properties":{}}],"question":"Fill in the blanks to create a valid Proc.\r\n[!raw!]\r\np = {0}.{1} do\r\n  puts \"I'm a Proc!\"\r\n{2}","textContent":"[h1]Procs[/h1]\r\n\r\nLet's create a program that counts the execution time of a block of code.\r\nWe will define a method that takes a proc as its parameter and counts the time it takes to execute the proc. [code format=\"rb\" ]def calc(proc)\r\n  start = Time.now\r\n  proc.call\r\n  dur = Time.now - start\r\nend[/code]\r\nLet's see it in action: [code format=\"rb\" codeId=\"1090\"]someProc = Proc.new do\r\n  num = 0\r\n  1000000.times do\r\n    num = num + 1\r\n  end\r\nend\r\n\r\nputs calc(someProc)[/code]\r\n[note]With that tiny [b]calc[/b] method, we can now easily calculate the execution time of any Ruby code![/note]"}]}}