{"lesson":{"id":2463,"name":"Decorators","type":0,"mode":1,"videoID":null,"tags":"decorators","quizzes":[{"id":5108,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":104449,"text":"Functions that modify other functions","isCorrect":true,"properties":{}},{"id":104450,"text":"Functions that return themselves","isCorrect":false,"properties":{}},{"id":104451,"text":"Functions with an at sign in their names","isCorrect":false,"properties":{}}],"question":"What are decorators?","textContent":"[h1]Decorators[/h1]\r\n\r\n[b]Decorators [/b]provide a way to modify functions using other functions. \r\nThis is ideal when you need to extend the functionality of functions that you don't want to modify.\r\n[b]Example:[/b] [code format=\"py\" codeId=\"391\"]def decor(func):\r\n  def wrap():\r\n    print(\"============\")\r\n    func()\r\n    print(\"============\")\r\n  return wrap\r\n\r\ndef print_text():\r\n  print(\"Hello world!\")\r\n\r\ndecorated = decor(print_text)\r\ndecorated()[/code]\r\nWe defined a function named [b]decor [/b]that has a single parameter [b]func[/b]. Inside [b]decor[/b], we defined a nested function named [b]wrap[/b]. The [b]wrap [/b]function will print a string, then call [b]func()[/b], and print another string. The [b]decor [/b]function returns the [b]wrap [/b]function as its result.\r\nWe could say that the variable [b]decorated [/b]is a decorated version of [b]print_text [/b]- it's [b]print_text [/b]plus something. \r\nIn fact, if we wrote a useful decorator we might want to replace [b]print_text [/b]with the decorated version altogether so we always got our \"plus something\" version of [b]print_text[/b]. \r\nThis is done by re-assigning the variable that contains our function:[code format=\"py\" codeId=\"392\"]print_text = decor(print_text)\r\nprint_text()[/code]\r\n[note]Now [b]print_text [/b]corresponds to our decorated version.[/note]"},{"id":5109,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":106638,"text":"@my_dec","isCorrect":true,"properties":{}},{"id":106639,"text":"my_dec(my_func)","isCorrect":false,"properties":{}},{"id":106640,"text":"my_func = @my_dec","isCorrect":false,"properties":{}}],"question":"Which statement can be used to achieve the same behavior as my_func = my_dec(my_func)?","textContent":"[h1]Decorators [/h1]\r\n\r\nIn our previous example, we decorated our function by replacing the variable containing the function with a wrapped version.[code format=\"py\" codeId=\"393\"]def print_text():\r\n  print(\"Hello world!\")\r\n\r\n[b]print_text = decor(print_text)[/b][/code]\r\nThis pattern can be used at any time, to wrap any function. \r\nPython provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name and the @ symbol. \r\nIf we are defining a function we can \"decorate\" it with the @ symbol like: [code format=\"py\" codeId=\"394\"][b]@decor[/b]\r\ndef print_text():\r\n  print(\"Hello world!\")[/code]\r\nThis will have the same result as the above code.\r\n[note]A single function can have multiple decorators.[/note]"}]}}