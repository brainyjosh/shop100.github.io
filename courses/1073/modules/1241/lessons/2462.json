{"lesson":{"id":2462,"name":"Generators","type":0,"mode":1,"videoID":null,"tags":"generators","quizzes":[{"id":5105,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":104566,"text":"return","isCorrect":false,"properties":{}},{"id":104567,"text":"generate","isCorrect":false,"properties":{}},{"id":104568,"text":"yield","isCorrect":true,"properties":{}}],"question":"What statement is used in functions to turn them into generators?","textContent":"[h1]Generators[/h1]\r\n\r\n[b]Generators [/b]are a type of iterable, like lists or tuples. \r\nUnlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated through with [b]for[/b] loops. \r\nThey can be created using functions and the [b]yield [/b]statement.\r\n[b]Example:[/b][code format=\"py\" codeId=\"388\"]def countdown():\r\n  i=5\r\n  while i > 0:\r\n    [b]yield [/b]i\r\n    i -= 1\r\n    \r\nfor i in countdown():\r\n  print(i)[/code]\r\n[b]Result:[/b][code format=\"raw\" ]>>>\r\n5\r\n4    \r\n3\r\n2\r\n1[/code]\r\n[note]The [b]yield [/b]statement is used to define a generator, replacing the return of a function to provide a result to its caller without destroying local variables.[/note]"},{"id":5106,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":104573,"text":"def","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":104574,"text":"yield","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to create a prime number generator, that yields all prime numbers in a loop. (Consider having an is_prime function already defined):\r\n[!raw!]\r\n{0} get_primes():\r\n  num = 2\r\n  while True:\r\n    if is_prime(num):\r\n      {1} num\r\n    num += 1","textContent":"[h1]Generators[/h1]\r\n\r\nDue to the fact that they [b]yield [/b]one item at a time, generators don't have the memory restrictions of lists. \r\nIn fact, they can be [b]infinite![/b][code format=\"py\" ]def infinite_sevens():\r\n  while True:\r\n    yield 7\r\n        \r\nfor i in infinite_sevens():\r\n  print(i)[/code]\r\n[b]Result:[/b][code format=\"raw\" ]>>>\r\n7\r\n7\r\n7\r\n7\r\n7\r\n7\r\n7\r\n...[/code]\r\n[note]In short, [b]generators [/b]allow you to declare a function that behaves like an iterator, i.e. it can be used in a [b]for [/b]loop.[/note]"},{"id":5107,"number":3,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":98213,"text":"\"spam\"","isCorrect":false,"properties":{}},{"id":98214,"text":"['s', 'sp', 'spa', 'spam']","isCorrect":true,"properties":{}},{"id":98215,"text":"['spam', 'spam', 'spam', 'spam']","isCorrect":false,"properties":{}}],"question":"What is the result of this code?\r\ndef make_word():\r\n  word = \"\"\r\n  for ch in \"spam\":\r\n    word +=ch\r\n    yield word\r\n\r\nprint(list(make_word()))","textContent":"[h1]Generators[/h1]\r\n\r\nFinite generators can be converted into lists by passing them as arguments to the [b]list [/b]function.[code format=\"py\" codeId=\"390\"]def numbers(x):\r\n  for i in range(x):\r\n    if i % 2 == 0:\r\n      yield i\r\n\r\nprint(list(numbers(11)))[/code]\r\n[b]Result:[/b] [code format=\"raw\" ]>>>\r\n[0, 2, 4, 6, 8, 10]\r\n>>>[/code]\r\n[note]Using [b]generators [/b]results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all the elements have been generated before we start to use them. [/note]"}]}}