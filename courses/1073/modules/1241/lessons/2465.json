{"lesson":{"id":2465,"name":"Recursion","type":0,"mode":1,"videoID":null,"tags":"recursion","quizzes":[{"id":5110,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":104575,"text":"A case that doesn't involve any further calls to that function","isCorrect":true,"properties":{}},{"id":104576,"text":"A case involving the number 1","isCorrect":false,"properties":{}},{"id":104577,"text":"A case that never occurs","isCorrect":false,"properties":{}}],"question":"What is the base case of a recursive function?","textContent":"[h1]Recursion[/h1]\r\n\r\n[b]Recursion [/b]is a very important concept in functional programming. \r\nThe fundamental part of recursion is self-reference - functions calling themselves. It is used to solve problems that can be broken up into easier sub-problems of the same type.\r\n\r\nA classic example of a function that is implemented recursively is the [b]factorial [/b]function, which finds the product of all positive integers below a specified number. \r\nFor example, 5! (5 factorial) is 5 * 4 * 3 * 2 * 1 (120). To implement this recursively, notice that 5! = 5 * 4!, 4! = 4 * 3!, 3! = 3 * 2!, and so on. Generally, n! = n * (n-1)!. \r\nFurthermore, 1! = 1. This is known as the [b]base case[/b], as it can be calculated without performing any more factorials. \r\nBelow is a recursive implementation of the factorial function. [code format=\"py\" codeId=\"395\"]def [b]factorial[/b](x):\r\n  if x == 1:\r\n    return 1\r\n  else: \r\n    return x * [b]factorial[/b](x-1)\r\n    \r\nprint(factorial(5))[/code]\r\n[b]Result:[/b] [code format=\"raw\" ]>>>\r\n120\r\n>>>[/code]\r\n[note]The [b]base case[/b] acts as the exit condition of the recursion.[/note]"},{"id":5111,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":98228,"text":"15","isCorrect":false,"properties":{}},{"id":98229,"text":"5","isCorrect":false,"properties":{}},{"id":98230,"text":"RuntimeError","isCorrect":true,"properties":{}}],"question":"What is the result of this code?\r\ndef sum_to(x):\r\n   return x + sum_to(x-1)\r\nprint (sum_to(5))","textContent":"[h1]Recursion[/h1]\r\n\r\nRecursive functions can be infinite, just like infinite [b]while[/b] loops. These often occur when you forget to implement the base case. \r\nBelow is an incorrect version of the factorial function. It has no base case, so it runs until the interpreter runs out of memory and crashes.[code format=\"py\" codeId=\"396\"]def factorial(x):\r\n  return x * [b]factorial[/b](x-1)\r\n    \r\nprint(factorial(5))[/code]\r\n[b]Result:[/b] [code format=\"raw\" ]>>>\r\nRuntimeError: maximum recursion depth exceeded\r\n>>>[/code]"},{"id":5112,"number":3,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":2,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":98231,"text":"5","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"What is the result of this code?\r\ndef fib(x):\r\n  if x == 0 or x == 1:\r\n    return 1\r\n  else: \r\n    return fib(x-1) + fib(x-2)\r\nprint(fib(4))","textContent":"[h1]Recursion[/h1]\r\n\r\nRecursion can also be indirect. One function can call a second, which calls the first, which calls the second, and so on. This can occur with any number of functions.\r\n[b]Example:[/b] [code format=\"py\" codeId=\"397\"]def [b]is_even[/b](x):\r\n  if x == 0:\r\n    return True\r\n  else:\r\n    return [b]is_odd[/b](x-1)\r\n\r\ndef [b]is_odd[/b](x):\r\n  return not [b]is_even[/b](x)\r\n\r\n\r\nprint(is_odd(17))\r\nprint(is_even(23))[/code]\r\n[b]Result:[/b] [code format=\"raw\" ]>>>\r\nTrue\r\nFalse\r\n>>>[/code]"}]}}