{"lesson":{"id":2470,"name":"Magic Methods & Operator Overloading","type":0,"mode":1,"videoID":null,"tags":"magic-methods","quizzes":[{"id":5133,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":2,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":98266,"text":"__init__","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"What is the magic method for creating an instance?","textContent":"[h1]Magic Methods[/h1]\r\n\r\n[b]Magic methods[/b] are special methods which have [b]double underscores[/b] at the beginning and end of their names. \r\nThey are also known as [b]dunders[/b]. \r\nSo far, the only one we have encountered is [b]__init__[/b], but there are several others. \r\nThey are used to create functionality that can't be represented as a normal method. \r\n\r\nOne common use of them is [b]operator overloading[/b]. \r\nThis means defining operators for custom classes that allow operators such as + and * to be used on them.\r\nAn example magic method is [b]__add__[/b] for +. [code format=\"py\" codeId=\"412\"]class Vector2D:\r\n  def __init__(self, x, y):\r\n    self.x = x\r\n    self.y = y\r\n  [b]def __add__(self, other):\r\n    return Vector2D(self.x + other.x, self.y + other.y)[/b]\r\n\r\nfirst = Vector2D(5, 7)\r\nsecond = Vector2D(3, 9)\r\nresult = first + second\r\nprint(result.x)\r\nprint(result.y)[/code]\r\n[b]Result:[/b] [code format=\"raw\" ]>>>\r\n8\r\n16    \r\n>>>[/code]\r\n[note]The [b]__add__[/b] method allows for the definition of a custom behavior for the + operator in our class. \r\nAs you can see, it adds the corresponding attributes of the objects and returns a new object, containing the result.\r\nOnce it's defined, we can add two objects of the class together.[/note]"},{"id":5134,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":98270,"text":"A().__xor__(B())","isCorrect":false,"properties":{}},{"id":98271,"text":"B().xor(A())","isCorrect":false,"properties":{}},{"id":98272,"text":"B().__rxor__(A())","isCorrect":true,"properties":{}}],"question":"What is A() ^ B() evaluated as, if A doesn't implement any magic methods?","textContent":"[h1]Magic Methods[/h1]\r\n\r\nMore magic methods for common operators:\r\n[b]__sub__[/b] for -\r\n[b]__mul__[/b] for *\r\n[b]__truediv__[/b] for /\r\n[b]__floordiv__[/b] for //\r\n[b]__mod__[/b] for %\r\n[b]__pow__[/b] for **\r\n[b]__and__[/b] for &\r\n[b]__xor__[/b] for ^\r\n[b]__or__[/b] for |\r\n\r\nThe expression [b]x + y[/b] is translated into [b]x.__add__(y)[/b]. \r\nHowever, if x hasn't implemented __add__, and x and y are of different types, then [b]y.__radd__(x)[/b] is called. \r\nThere are equivalent [b]r[/b] methods for all magic methods just mentioned.\r\n[b]Example:[/b] [code format=\"py\" codeId=\"413\"]class SpecialString:\r\n  def __init__(self, cont):\r\n    self.cont = cont\r\n\r\n  [b]def __truediv__(self, other):\r\n    line = \"=\" * len(other.cont)\r\n    return \"\\n\".join([self.cont, line, other.cont])[/b]\r\n\r\nspam = SpecialString(\"spam\")\r\nhello = SpecialString(\"Hello world!\")\r\n[b]print(spam / hello)[/b][/code]\r\n[b]Result:[/b] [code format=\"raw\" ]>>>\r\nspam\r\n============\r\nHello world!\r\n>>>[/code]\r\n[note]In the example above, we defined the [b]division [/b]operation for our class [b]SpecialString[/b].[/note]"},{"id":5135,"number":3,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":98273,"text":"x >= y","isCorrect":false,"properties":{}},{"id":98274,"text":"x < y","isCorrect":false,"properties":{}},{"id":98275,"text":"x <= y","isCorrect":true,"properties":{}}],"question":"What is __le__ a magic method for?","textContent":"[h1]Magic Methods[/h1]\r\n\r\nPython also provides magic methods for comparisons.\r\n[b]__lt__[/b] for <\r\n[b]__le__[/b] for <=\r\n[b]__eq__[/b] for ==\r\n[b]__ne__[/b] for !=\r\n[b]__gt__[/b] for >\r\n[b]__ge__[/b] for >=\r\n\r\n If [b]__ne__[/b] is not implemented, it returns the opposite of [b]__eq__[/b]. \r\nThere are no other relationships between the other operators.\r\n[b]Example:[/b]  [code format=\"py\" codeId=\"414\"]class SpecialString:\r\n  def __init__(self, cont):\r\n    self.cont = cont\r\n\r\n  def __gt__(self, other):\r\n    for index in range(len(other.cont)+1):\r\n      result = other.cont[:index] + \">\" + self.cont\r\n      result += \">\" + other.cont[index:]\r\n      print(result)\r\n\r\nspam = SpecialString(\"spam\")\r\neggs = SpecialString(\"eggs\")\r\nspam > eggs[/code]\r\n[b]Result:[/b] [code format=\"raw\" ]>>>\r\n>spam>eggs\r\ne>spam>ggs\r\neg>spam>gs\r\negg>spam>s\r\neggs>spam>\r\n>>>[/code]\r\n[note]As you can see, you can define any custom behavior for the overloaded operators.[/note]"},{"id":5136,"number":4,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":104468,"text":"x.setitem(z, y)","isCorrect":false,"properties":{}},{"id":104469,"text":"x.__setitem__(y, z)","isCorrect":true,"properties":{}},{"id":104470,"text":"y.__getitem__(x, z)","isCorrect":false,"properties":{}}],"question":"Which magic method call is made by x[y] = z?","textContent":"[h1]Magic Methods[/h1]\r\n\r\nThere are several magic methods for making classes act like containers.\r\n[b]__len__ [/b]for len()\r\n[b]__getitem__[/b] for indexing\r\n[b]__setitem__[/b] for assigning to indexed values\r\n[b]__delitem__[/b] for deleting indexed values\r\n[b]__iter__[/b] for iteration over objects (e.g., in for loops)\r\n[b]__contains__[/b] for in\r\n\r\nThere are many other magic methods that we won't cover here, such as [b]__call__ [/b]for calling objects as functions, and [b]__int__[/b], [b]__str__[/b], and the like, for converting objects to built-in types. \r\n[b]Example:[/b][code format=\"py\" codeId=\"415\"]import random\r\n\r\nclass VagueList:\r\n  def __init__(self, cont):\r\n    self.cont = cont\r\n\r\n  [b]def __getitem__(self, index):\r\n    return self.cont[index + random.randint(-1, 1)]\r\n\r\n  def __len__(self):\r\n    return random.randint(0, len(self.cont)*2)[/b]\r\n\r\nvague_list = VagueList([\"A\", \"B\", \"C\", \"D\", \"E\"])\r\nprint(len(vague_list))\r\nprint(len(vague_list))\r\nprint(vague_list[2])\r\nprint(vague_list[2])[/code]\r\n[b]Result:[/b] [code format=\"raw\" ]>>>\r\n6\r\n7\r\nD\r\nC\r\n>>>[/code]\r\n[note]We have overridden the len() function for the class VagueList to return a random number.\r\nThe indexing function also returns a random item in a range from the list, based on the expression.[/note]"}]}}