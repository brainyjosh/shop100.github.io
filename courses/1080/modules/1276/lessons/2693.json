{"lesson":{"id":2693,"name":"Generic Methods","type":0,"mode":1,"videoID":null,"tags":"generics","quizzes":[{"id":5598,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":104264,"text":"<","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":104265,"text":">","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":104266,"text":"x","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to declare a generic method that displays its argument value.\r\n[!raw!]\r\nstatic void Print{0}T{1}(T x)\r\n{\r\n  Console.WriteLine({2});\r\n}","textContent":"[h1]Generics[/h1]\r\n\r\n[b]Generics [/b]allow the reuse of code across different types.\r\nFor example, let's declare a method that swaps the values of its two parameters: [code format=\"cs\" ]static void Swap(ref int a, ref int b) {\r\n  int temp = a;\r\n  a = b;\r\n  b = temp;\r\n}[/code]\r\nOur [b]Swap [/b]method will work only for integer parameters. If we want to use it for other types, for example, doubles or strings, we have to overload it for all the types we want to use it with. Besides a lot of code repetition, it becomes harder to manage the code because changes in one method mean changes to all of the overloaded methods.\r\nGenerics provide a flexible mechanism to define a generic type. [code format=\"cs\" ]static void Swap[b]<T>[/b](ref [b]T[/b] a, ref [b]T[/b] b) {\r\n  [b]T[/b] temp = a;\r\n  a = b;\r\n  b = temp;\r\n}[/code]\r\nIn the code above, [b]T[/b] is the name of our generic type. We can name it anything we want, but [b]T[/b] is a commonly used name. Our Swap method now takes two parameters of type [b]T[/b]. We also use the [b]T[/b] type for our [b]temp [/b]variable that is used to swap the values.\r\n[note]Note the brackets in the syntax [b]<T>[/b], which are used to define a generic type.[/note]"},{"id":5599,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":104283,"text":",","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":104284,"text":">","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":104285,"text":",","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":104286,"text":"y","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to use the generic method Func for the x and y variables:\r\n[!raw!]\r\nstatic void Func<T{0} U{1}(T x{2} U y) {\r\n  Console.WriteLine(x+\" \"+y);\r\n}\r\nstatic void Main(string[] args) {\r\n  double x = 7.42;\r\n  string y = \"test\";\r\n  Func(x, {3});\r\n}","textContent":"[h1]Generic Methods[/h1]\r\n\r\nNow, we can use our [b]Swap [/b]method with different types, as in: [code format=\"cs\" codeId=\"916\"]static void Swap<T>(ref T a, ref T b) {\r\n  T temp = a;\r\n  a = b;\r\n  b = temp;\r\n}\r\nstatic void Main(string[] args) {\r\n  int a = 4, b = 9;\r\n  Swap[b]<int>[/b](ref a, ref b);\r\n  //Now b is 4, a is 9\r\n\r\n  string x = \"Hello\";\r\n  string y = \"World\";\r\n  Swap[b]<string>[/b](ref x, ref y);\r\n  //Now x is \"World\", y is \"Hello\"\r\n}[/code]\r\nWhen calling a generic method, we need to specify the type it will work with by using brackets. So, when [b]Swap<int>[/b] is called, the [b]T[/b] type is replaced by [b]int[/b]. For [b]Swap<string>[/b], [b]T[/b] is replaced by [b]string[/b]. \r\nIf you omit specifying the type when calling a generic method, the compiler will use the type based on the arguments passed to the method.\r\n[note]Multiple generic parameters can be used with a single method. \r\nFor example: [b]Func<T, U>[/b] takes two different generic types.[/note]"}]}}