{"lesson":{"id":2683,"name":"Abstract Classes","type":0,"mode":1,"videoID":null,"tags":"abstract-classes","quizzes":[{"id":5568,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":104030,"text":"abstract","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":104031,"text":"abstract","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":104032,"text":";","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to define an abstract method Print for class A:\r\n[!raw!]\r\n{0} class A \r\n{\r\n  public {1} void Print(){2}\r\n}","textContent":"[h1]Abstract Classes[/h1]\r\n\r\nAs described in the previous example, polymorphism is used when you have different derived classes with the same method, which has different implementations in each class. This behavior is achieved through [b]virtual[/b] methods that are [b]overridden[/b] in the derived classes.\r\nIn some situations there is no meaningful need for the virtual method to have a separate definition in the base class.\r\nThese methods are defined using the [b]abstract[/b] keyword and specify that the derived classes must define that method on their own. \r\nYou cannot create objects of a class containing an abstract method, which is why the class itself should be abstract.\r\nWe could use an abstract method in the Shape class: [code format=\"cs\" ][b]abstract [/b]class Shape {\r\n   public [b]abstract [/b]void Draw();\r\n}[/code]\r\nAs you can see, the [b]Draw[/b] method is [b]abstract[/b] and thus has no body. You do not even need the curly brackets; just end the statement with a semicolon.\r\nThe Shape class itself must be declared [b]abstract[/b] because it contains an [b]abstract[/b] method. Abstract method declarations are only permitted in abstract classes.\r\n[note]Remember, [b]abstract [/b]method declarations are only permitted in [b]abstract [/b]classes. Members marked as [b]abstract[/b], or included in an abstract class, must be implemented by classes that derive from the abstract class. An abstract class can have multiple abstract members.[/note]"},{"id":5569,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":104053,"text":"class","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":104054,"text":"abstract","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":104055,"text":":","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":104056,"text":"override","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to create an abstract class with an abstract method and then use it as a base class.\r\n[!raw!]\r\nabstract {0} Animal {\r\n  public {1} void Eat();\r\n}\r\nclass Dog{2} Animal {\r\n  public {3} void Eat() {\r\n    Console.WriteLine(\"Omnomnom\");\r\n  }\r\n}","textContent":"[h1]Abstract Classes[/h1]\r\n\r\nAn abstract class is intended to be a base class of other classes. It acts like a template for its derived classes.\r\nNow, having the abstract class, we can derive the other classes and define their own [b]Draw[/b]() methods: [code format=\"cs\" codeId=\"902\"]abstract class Shape {\r\n  public abstract void Draw();\r\n}\r\nclass Circle : Shape {\r\n  public override void Draw() {\r\n    Console.WriteLine(\"Circle Draw\");\r\n  }\r\n}\r\nclass Rectangle : Shape {\r\n  public override void Draw() {\r\n    Console.WriteLine(\"Rect Draw\");\r\n  }\r\n}\r\nstatic void Main(string[] args) {\r\n  [b]Shape [/b]c = new [b]Circle[/b]();\r\n  c.Draw();\r\n  //Outputs \"Circle Draw\"\r\n}[/code]\r\nAbstract classes have the following features:\r\n- An abstract class cannot be instantiated.\r\n- An abstract class may contain abstract methods and accessors.\r\n- A non-abstract class derived from an abstract class must include actual implementations of all inherited abstract methods and accessors.\r\n[note]It is not possible to modify an [b]abstract [/b]class with the [b]sealed [/b]modifier because the two modifiers have opposite meanings. The [b]sealed [/b]modifier prevents a class from being inherited and the [b]abstract [/b]modifier requires a class to be inherited.[/note]"}]}}