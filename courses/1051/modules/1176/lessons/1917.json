{"lesson":{"id":1917,"name":"Template Specialization","type":0,"mode":1,"videoID":"8kjVFp-Y4GA","tags":"templates","quizzes":[{"id":3803,"number":1,"videoStart":12.0,"videoEnd":180.0,"linkedVideoID":null,"type":6,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":95266,"text":"template","isCorrect":true,"properties":{}},{"id":95267,"text":"class","isCorrect":true,"properties":{}},{"id":95268,"text":"T","isCorrect":true,"properties":{}},{"id":95269,"text":"int","isCorrect":false,"properties":{}},{"id":95270,"text":"public","isCorrect":false,"properties":{}},{"id":95271,"text":"protected","isCorrect":false,"properties":{}}],"question":"Fill in the blanks to declare a class template ''Spunky''.\r\n[!raw!]\r\n{0} <class T>\r\n{1} Spunky {\r\npublic:\r\n   Spunky({2} x) { \r\n   cout << x <<\r\n    \" is not a character\" << endl;  }\r\n};","textContent":"[h1]Template Specialization [/h1]\r\n\r\nIn case of regular class templates, the way the class handles different data types is the same; the same code runs for all data types.\r\n[b]Template specialization[/b] allows for the definition of a different implementation of a template when a specific type is passed as a template argument.\r\n\r\nFor example, we might need to handle the character data type in a different manner than we do numeric data types.\r\nTo demonstrate how this works, we can first create a regular template.[code format=\"cpp\"]template <class T>\r\nclass MyClass {\r\n public:\r\n  MyClass (T x) {\r\n   cout <<x<<\" -  not a char\"<<endl;\r\n  }\r\n};[/code]\r\n[note]As a regular class template, [b]MyClass [/b]treats all of the various data types in the same way.[/note]"},{"id":3804,"number":2,"videoStart":192.0,"videoEnd":326.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":105615,"text":"<>","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":105616,"text":"char","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to specialize the ''Spunky'' template class for the characters.\r\n[!raw!]\r\ntemplate {0}\r\nclass Spunky<{1}>\r\n{\r\npublic:\r\n  Spunky(char x) { \r\n   cout << x << \"is a char\" << endl; }\r\n};","textContent":"[h1]Template Specialization[/h1]\r\n\r\nTo specify different behavior for the data type [b]char[/b], we would create a template specialization.[code format=\"cpp\" ]template <class T>\r\nclass MyClass {\r\n public:\r\n  MyClass (T x) {\r\n   cout <<x<<\" -  not a char\"<<endl;\r\n  }\r\n};\r\n\r\n[b]template < >[/b]\r\nclass MyClass<[b]char[/b]> {\r\n public:\r\n  MyClass ([b]char [/b]x) {\r\n   cout <<x<<\" is a char!\"<<endl;\r\n  }\r\n};[/code]\r\nFirst of all, notice that we precede the class name with [b]template<>[/b], including an empty parameter list. This is because all types are known and no template arguments are required for this specialization, but still, it is the specialization of a class template, and thus it requires to be noted as such.\r\n\r\nBut more important than this prefix, is the <[b]char[/b]> specialization parameter after the class template name. This specialization parameter itself identifies the type for which the template class is being specialized ([b]char[/b]). \r\n[note]In the example above, the first class is the generic template, while the second is the specialization.\r\nIf necessary, your specialization can indicate a completely different behavior from the behavior of your the generic template.[/note]"},{"id":3805,"number":3,"videoStart":338.0,"videoEnd":488.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":97894,"text":"int","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":97895,"text":"<","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":97896,"text":"char","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to declare three objects of type ''Spunky'': i, d, ch, where i's template parameter is integer, d's template parameter is double and ch's is character.\r\n[!raw!]\r\nint main()\r\n{\r\n Spunky<{0}> i(4);\r\n Spunky{1}double> d(3.14);\r\n Spunky<{2}> ch('z');\r\n}","textContent":"[h1]Template Specialization[/h1]\r\n\r\nThe next step is to declare objects of different types and check the result:[code format=\"cpp\" codeId=\"281\"]int main () {\r\n  MyClass<[b]int[/b]> ob1(42);\r\n  MyClass<[b]double[/b]> ob2(5.47);\r\n  MyClass<[b]char[/b]> ob3('s');\r\n}\r\n/* Output: \r\n42 - not a char\r\n5.47 - not a char\r\ns is a char!\r\n*/[/code]\r\nAs you can see, the generic template worked for [b]int [/b]and [b]double[/b]. However, our template specialization was invoked for the [b]char [/b]data type.\r\n[note]Keep in mind that there is no member \"inheritance\" from the generic template to the specialization, so all members of the template class specializations must be defined on their own. [/note]"}]}}