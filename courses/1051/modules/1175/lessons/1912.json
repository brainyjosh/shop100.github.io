{"lesson":{"id":1912,"name":"Abstract Classes","type":0,"mode":1,"videoID":"ndz3EHpFEZc","tags":"abstract-classes","quizzes":[{"id":3777,"number":1,"videoStart":12.0,"videoEnd":127.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":97876,"text":"...it calls the base class' function","isCorrect":false,"properties":{}},{"id":97877,"text":"...it calls those class' function to which the base class pointer points","isCorrect":true,"properties":{}},{"id":97878,"text":"...it does nothing","isCorrect":false,"properties":{}}],"question":"When a virtual function is called via base class pointer...","textContent":"[h1]Virtual Functions[/h1]\r\n\r\nVirtual functions can also have their implementation in the base class: [code format=\"cpp\" ]class Enemy {\r\n public:\r\n[b]  virtual void attack() {\r\n   cout << \"Enemy!\"<<endl;\r\n  }[/b]\r\n};\r\n\r\nclass Ninja: public Enemy {\r\n public:\r\n  void attack() {\r\n   cout << \"Ninja!\"<<endl;\r\n  }\r\n};\r\n\r\nclass Monster: public Enemy {\r\n public:\r\n  void attack() {\r\n   cout << \"Monster!\"<<endl;\r\n  }\r\n};[/code]\r\nNow, when you create an [b]Enemy [/b]pointer, and call the [b]attack()[/b] function, the compiler will call the function, which corresponds to the object's type, to which the pointer points: [code format=\"cpp\" codeId=\"272\"]int main() {\r\n Ninja n;\r\n Monster m;\r\n Enemy e;\r\n\r\n Enemy *e1 = &n;\r\n Enemy *e2 = &m;\r\n Enemy *e3 = &e;\r\n\r\n e1->attack();\r\n // Outputs \"Ninja!\"\r\n\r\n e2->attack();\r\n // Outputs \"Monster!\"\r\n\r\n e3->attack();\r\n // Outputs \"Enemy!\"\r\n}[/code]\r\n[note]This is how [b]polymorphism [/b]is generally used. You have different classes with a function of the same name, and even the same parameters, but with different implementations.[/note]"},{"id":3778,"number":2,"videoStart":128.0,"videoEnd":202.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":95216,"text":"virtual","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":95217,"text":"=","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to declare a pure virtual function ''foo()''.\r\n[!raw!]\r\n{0} void foo() {1} 0;","textContent":"[h1]Pure Virtual Function [/h1]\r\n\r\nIn some situations you'd want to include a virtual function in a base class so that it may be redefined in a derived class to suit the objects of that class, but that there is no meaningful definition you could give for the function in the base class.\r\nThe virtual member functions without definition are known as [b]pure virtual functions[/b]. They basically specify that the derived classes define that function on their own.\r\nThe syntax is to replace their definition by =0 (an equal sign and a zero): [code format=\"cpp\"]class Enemy {\r\n public:\r\n  [b]virtual void attack() = 0[/b];\r\n}; [/code]\r\n[note]The = 0 tells the compiler that the function has no body.[/note]"},{"id":3779,"number":3,"videoStart":203.0,"videoEnd":244.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":99462,"text":"...must have an implementation","isCorrect":false,"properties":{}},{"id":99463,"text":"...has no body and must be implemented in derived classes","isCorrect":true,"properties":{}},{"id":99464,"text":"...must always return void","isCorrect":false,"properties":{}}],"question":"A pure virtual function...","textContent":"[h1]Pure Virtual Functions[/h1]\r\n\r\nA [b]pure virtual function [/b]basically defines, that the derived classes will have that function defined on their own.\r\nEvery derived class inheriting from a class with a pure virtual function [b]must[/b] override that function. \r\n[note]If the pure virtual function is not overridden in the derived class, the code fails to compile and results in an error when you try to instantiate an object of the derived class.[/note]"},{"id":3780,"number":4,"videoStart":293.0,"videoEnd":328.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":95218,"text":"virtual","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":95219,"text":"=","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":95220,"text":"public","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":95221,"text":"void","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to declare a ''Person'' class with a ''sayHello()'' pure virtual function and override it in the derived ''Student'' class.\r\n[!raw!]\r\nclass Person {\r\npublic:\r\n {0} void sayHello() {1} 0;\r\n};\r\nclass Student : {2} Person {\r\npublic:\r\n {3} sayHello() { \r\n   cout << \"Student says hello\"; }\r\n};","textContent":"[h1]Pure Virtual Functions[/h1]\r\n\r\nThe pure virtual function in the [b]Enemy [/b]class must be overridden in its derived classes.[code format=\"cpp\"]class Enemy {\r\n public:\r\n  [b]virtual void attack() = 0;[/b]\r\n};\r\n\r\nclass Ninja: public Enemy {\r\n public:\r\n  void attack() {\r\n   cout << \"Ninja!\"<<endl;\r\n  }\r\n};\r\n\r\nclass Monster: public Enemy {\r\n public:\r\n  void attack() {\r\n   cout << \"Monster!\"<<endl;\r\n  }\r\n};[/code]"},{"id":3781,"number":5,"videoStart":357.0,"videoEnd":407.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":97873,"text":"...was declared using the ''abstract'' keyword","isCorrect":false,"properties":{}},{"id":97874,"text":"...has a pure virtual function","isCorrect":true,"properties":{}},{"id":97875,"text":"...has at least two methods declared","isCorrect":false,"properties":{}}],"question":"An abstract class is a class that...","textContent":"[h1]Abstract Classes[/h1]\r\n\r\nYou [b]cannot [/b]create objects of the base class with a pure virtual function.\r\nRunning the following code will return an error:[code format=\"cpp\" codeId=\"274\"]Enemy e; // Error[/code]\r\nThese classes are called [b]abstract[/b]. They are classes that can only be used as base classes, and thus are allowed to have pure virtual functions.\r\n\r\nYou might think that an abstract base class is useless, but it isn't. It can be used to create pointers and take advantage of all its polymorphic abilities. \r\nFor example, you could write: [code format=\"cpp\" codeId=\"273\"]Ninja n;\r\nMonster m;\r\nEnemy *e1 = &n;\r\nEnemy *e2 = &m;\r\n\r\ne1->attack();\r\ne2->attack();[/code]\r\n[note]In this example, objects of different but related types are referred to using a unique type of pointer (Enemy*), and the proper member function is called every time, just because they are virtual.[/note]"}]}}