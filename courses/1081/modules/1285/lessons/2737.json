{"lesson":{"id":2737,"name":"Modules and Mixins","type":0,"mode":1,"videoID":null,"tags":"modules mixins","quizzes":[{"id":5763,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":113422,"text":"module","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":113423,"text":"def","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":113424,"text":"end","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to define a module Speakable, containing a method speak.\r\n[!raw!]\r\n{0} Speakable\r\n  {1} speak\r\n    puts \"Hey\" \r\n  {2}\r\nend ","textContent":"[h1]Modules[/h1]\r\n\r\nExtracting common methods to a superclass, like we did in the previous section, is a great way to model concepts that are naturally hierarchical (a Cat is an Animal which is a Mammal).\r\nAnother way of grouping methods together are [b]modules[/b].\r\nA [b]module [/b]is a collection of methods that can be used in other classes (think about them as libraries providing common functionality).\r\nModules are defined using the [b]module [/b]keyword followed by the module name, which should start with a capital letter.\r\n[b]For example: [/b] [code format=\"rb\" ][b]module [/b]Flyable\r\n  def fly\r\n    puts \"I'm flying!\"\r\n  end\r\nend[/code]\r\nThe code above declares a module called [b]Flyable[/b], which includes one method called \"[b]fly[/b]\".\r\nA module can include as many methods as you want.\r\n[note]As you can see the syntax is very similar to defining classes.\r\nBut why use modules instead of classes? Tap [b]Continue [/b]to discover![/note]"},{"id":5764,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":6,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":113430,"text":"module","isCorrect":true,"properties":{}},{"id":113431,"text":"include","isCorrect":true,"properties":{}},{"id":113432,"text":"mix","isCorrect":false,"properties":{}},{"id":113433,"text":"end","isCorrect":false,"properties":{}},{"id":113434,"text":"class","isCorrect":false,"properties":{}}],"question":"Fill in the blanks to mix in the module Runnable into the class Person.\r\n[!raw!]\r\n{0} Runnable\r\nend\r\nclass Person\r\n{1} Runnable\r\nend","textContent":"[h1]Modules[/h1]\r\n\r\nNow, imagine having a class hierarchy, with a superclass Vehicle and subclasses: Car, Jet, Plane.\r\nAll have some shared functionality, which they inherit from the Vehicle class, but only Jet and Plane can fly. \r\nInstead of defining separate fly methods for both classes, we can define a module and [b]include [/b]it (commonly referred to as \"[b]mix[/b]\" it) in the classes. [code format=\"rb\" ]module Flyable\r\n  def fly\r\n    puts \"I'm flying!\"\r\n  end\r\nend\r\n\r\nclass Vehicle\r\nend\r\n\r\nclass Car < Vehicle\r\nend\r\n\r\nclass Jet < Vehicle\r\n[b]  include Flyable[/b]\r\nend\r\n\r\nclass Plane < Vehicle\r\n[b]  include Flyable[/b]\r\nend[/code]\r\nNow Jet and Plane objects can fly, but objects of other classes won't be able to: [code format=\"rb\" codeId=\"1079\"]ob = Jet.new\r\nob.fly[/code]\r\n[note]A common naming convention for Ruby is to use the \"able\" suffix on whatever verb describes the behavior that the module is modeling, like Walkable, Swimmable, Runnable, etc. \r\nNot all modules are named in this manner, however, it is quite common.[/note]"},{"id":5765,"number":3,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":113437,"text":"Yes","isCorrect":false,"properties":{}},{"id":113438,"text":"No","isCorrect":true,"properties":{}}],"question":"Can you instantiate modules?","textContent":"[h1]Modules[/h1]\r\n\r\nAs you may recall, Ruby does not allow a class to inherit from multiple classes. \r\nHowever, a class can mix in [b]multiple [/b]modules. Modules used this way are known as \"[b]mixins[/b]\".\r\nSo, basically, a class can have multiple [b]mixins[/b]: [code format=\"rb\" ]class Human\r\n  include Walkable\r\n  include Speakable\r\n  include Runnable\r\nend[/code]\r\nIt is important to remember the following:\r\n1. You can only inherit from one class. But you can mix in as many modules as you'd like.\r\n\r\n2. If it's an \"[b]is-a[/b]\" relationship, choose class inheritance. If it's a \"[b]has-a[/b]\" relationship, choose modules. Example: a plane \"is a\" vehicle; a plane \"has an\" ability to fly.\r\n\r\n3. You cannot instantiate modules (i.e., an object cannot be created from a module). \r\nModules are used only for grouping common methods together. \r\nClasses are about objects; modules are about methods.\r\n[note]Mixins give you a great, controlled way of adding functionality to classes. [/note]"},{"id":5917,"number":4,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":1,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":113443,"text":"<=>","isCorrect":true,"properties":{}},{"id":113444,"text":"<","isCorrect":false,"properties":{}},{"id":113445,"text":">","isCorrect":false,"properties":{}},{"id":113446,"text":"==","isCorrect":false,"properties":{}}],"question":"Which operator do you need to define after adding the Comparable mixin to your class to enable the comparison operators?","textContent":"[h1]Mixins[/h1]\r\n\r\nThe true power of mixins comes out when the code in the mixin starts to interact with code in the class that uses it. Ruby has a number of predefined mixins ready for you to use.\r\nLet's take the standard Ruby mixin [b]Comparable [/b]as an example. The Comparable mixin can be used to add the comparison operators (<, <=, ==, >=, and >) to a class. \r\nFor this to work, Comparable assumes that any class that uses it defines the operator [b]<=>[/b]. \r\nSo, as a class writer, you define the one method, <=>, include [b]Comparable[/b], and get six comparison functions as a result!\r\nLet's try this with our Cat class, by making the cats comparable based on their age.\r\nAll we have to do is include the Comparable module and implement the comparison operator <=>. [code format=\"rb\" codeId=\"1080\"]class Cat\r\n  attr_accessor :name, :age\r\n  include [b]Comparable[/b]\r\n  def initialize(n, a)\r\n    self.name = n\r\n    self.age = a\r\n  end\r\n  def [b]<=>[/b](other)\r\n    self.age <=> other.age\r\n  end\r\nend\r\n\r\nc1 = Cat.new(\"Bob\", 3)\r\nc2 = Cat.new(\"Lucy\", 7)\r\n\r\nputs c1 < c2 # true[/code]\r\n[note]The Comparable module allows you to easily add comparison operators based on any custom logic to your classes.[/note]"}]}}