{"lesson":{"id":2739,"name":"Namespacing","type":0,"mode":1,"videoID":null,"tags":"modules","quizzes":[{"id":5772,"number":1,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":113449,"text":"::","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":113450,"text":"new","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to instantiate an object of the class Car, which is included in the module Machine.\r\n[!raw!]\r\na = Machine{0}Car.{1}","textContent":"[h1]Namespacing[/h1]\r\n\r\nWe've already seen how modules can be used to mix-in common behavior into classes. Now we'll see two more uses for modules.\r\nThe first case we'll discuss is using modules for [b]namespacing[/b].\r\nIn this context, [b]namespacing [/b]means organizing similar classes in a module. In other words, we'll use modules to group related classes.\r\n[b]For example:[/b] [code format=\"rb\" ]module Mammal\r\n  class Dog\r\n    def speak\r\n      puts \"Woof!\"\r\n    end\r\n  end\r\n\r\n  class Cat\r\n    def speak\r\n      puts \"Meow\"\r\n    end\r\n  end\r\nend[/code]\r\nWe defined a module Mammal which groups together two classes, Dog and Cat.\r\nNow we can call classes in the module by appending the class name to the module name with[b] two colons(::)[/b]: [code format=\"rb\" codeId=\"1081\"]a = Mammal[b]::[/b]Dog.new\r\nb = Mammal[b]::[/b]Cat.new\r\n\r\na.speak  # \"Woof\"\r\nb.speak  # \"Meow\"[/code]\r\n[note]The advantages of namespacing classes:\r\nIt becomes easy for us to recognize related classes in our code. \r\nIt reduces the likelihood of our classes colliding with other similarly named classes in our code. We can have the same class names across different modules.[/note]"},{"id":5773,"number":2,"videoStart":0.0,"videoEnd":0.0,"linkedVideoID":null,"type":3,"linkedQuizID":null,"tip":null,"hint":null,"time":0,"answers":[{"id":113454,"text":"module","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":113455,"text":"self.","isCorrect":false,"properties":{"prefix":"","postfix":""}},{"id":113456,"text":"shuffle","isCorrect":false,"properties":{"prefix":"","postfix":""}}],"question":"Fill in the blanks to define a module \"Stuff\", with a class method \"shuffle\" and call it.\r\n[!raw!]\r\n{0} Stuff\r\n  def {1}shuffle\r\n  end\r\nend\r\nStuff.{2}","textContent":"[h1]Namespacing[/h1]\r\n\r\nAnother use for modules is as containers for methods.\r\nThis allows us to group together relevant methods and use them in our code. \r\n[b]For example:[/b] [code format=\"rb\" codeId=\"1082\"]module MyMath\r\n  PI = 3.14\r\n  def self.square(x)\r\n    x*x\r\n  end\r\n  def self.negate(x)\r\n    -x\r\n  end\r\n  def self.factorial(x)\r\n     (1..x).inject(:*) || 1\r\n  end\r\nend\r\n\r\nputs MyMath.factorial(8)[/code]\r\nThe code above defines a module called MyMath, which includes a constant called PI, and three class methods. The methods inside a module are defined as class methods (note the [b]self [/b]keyword), and we call them using the dot syntax. \r\nYou can call the methods using two colon syntax (::) as well (MyMath::factorial(8)), but the dot syntax is preferred.\r\n[note]Again, the advantages of using modules to group methods includes preventing name collisions, meaning that we can have the same method names across multiple modules.[/note]"}]}}